\documentclass[10pt, a4paper, oneside, fontset=none]{ctexart}

%调用宏包
\usepackage{amsmath, amsthm, amssymb, graphicx, wrapfig, mathrsfs}
\usepackage[bookmarks=true, colorlinks, citecolor=blue, linkcolor=black]{hyperref}
\usepackage{color, framed, geometry, tcolorbox, nicematrix, xcolor}
\tcbuselibrary{breakable}%box跨页
\tcbuselibrary{skins}%box跨页不留边
\usepackage{makecell, booktabs, listings, float}
\usepackage[labelfont=bf, justification=raggedleft]{caption}
\usepackage{multicol}
\usepackage{extarrows}
\usepackage{enumitem}
\usepackage{yhmath}
\usepackage{multirow}
\usepackage[text=\includegraphics{C:/Users/16870/.vscode/LaTeX_Application/tex/23Au/图标简稿.png},angle=0]{draftwatermark}%水印
%\usepackage{tikz}

%基本字体设置
\usepackage[math-style=ISO, bold-style=ISO]{unicode-math}
%\newcommand{\symbf}[1]{\boldsymbol{#1}}
%\newcommand{\symup}[1]{\mathrm{#1}}
\setmonofont{Iosevka}
\newfontfamily{\mono}{Cascadia Mono Regular}
\setCJKmainfont{方正书宋_GBK}[BoldFont={思源宋体 CN Bold}, ItalicFont=方正楷体_GBK, BoldItalicFont={汉仪颜楷W}]
\setCJKsansfont{汉仪文黑-45W ExtraLight}[BoldFont={汉仪文黑-75W Bold}, ItalicFont={方正颜真卿楷书 简繁}]
\setCJKmonofont{LXGWNeoXiHei.ttf}[BoldFont=FZYZHHJ(20110330).TTF]
%附加字体设置
\newCJKfontfamily{\kaico}{可口可乐在乎体 楷体}
\newCJKfontfamily{\kai}{方正楷体_GBK}[BoldFont={汉仪颜楷W}, ItalicFont={方正清刻本悦宋 简繁}, BoldItalicFont={方正颜真卿楷书 简繁}]
\newCJKfontfamily{\yan}{方正清刻本悦宋 简繁}[ItalicFont={方正颜真卿楷书 简繁}]
\newCJKfontfamily{\xiu}{方正宋刻本秀楷_GBK}[ItalicFont={方正宋刻本秀楷_GBK}, BoldFont={方正颜真卿楷书 简繁}]
\newCJKfontfamily{\run}{汉仪润圆-45W}[BoldFont=汉仪润圆-75W, ItalicFont={汉仪润圆-45W}]
\newCJKfontfamily{\wen}{汉仪文黑-45W ExtraLight}[BoldFont={汉仪文黑-75W Bold}, ItalicFont={汉仪文黑-85W Heavy}]

%文档格式
\geometry{left=1.96cm, right=1.96cm, top=3.18cm, bottom=3.18cm}
\setcounter{tocdepth}{3}
\setcounter{secnumdepth}{4}
\linespread{1.4}
\renewcommand{\theparagraph}{\Alph{paragraph})}
\newcommand{\Section}[1]{ \refstepcounter{section} \section*{*\thesection\texorpdfstring{\quad}{} #1} \addcontentsline{toc}{section}{\makebox[0pt][r]{*}\thesection\texorpdfstring{\quad}{} #1} }
\newcommand{\Subsection}[1]{ \refstepcounter{subsection} \subsection*{*\thesubsection\texorpdfstring{\quad}{} #1} \addcontentsline{toc}{subsection}{\makebox[0pt][r]{*}\thesubsection\texorpdfstring{\quad}{} #1} }
\newcommand{\Subsubsection}[1]{ \refstepcounter{subsubsection} \subsubsection*{*\thesubsubsection\texorpdfstring{\quad}{} #1} \addcontentsline{toc}{subsubsection}{\makebox[0pt][r]{*}\thesubsubsection\texorpdfstring{\quad}{} #1} }
\setlist[itemize]{leftmargin=3em, labelsep=0.25em, itemindent=0em, itemsep=0pt, parsep=0pt, topsep=3pt, partopsep=0pt}
\setlength{\columnsep}{1cm} % 分栏间距
\setlength{\columnseprule}{.4pt} % 栏分割线粗
\setlength{\abovecaptionskip}{0.2em}
\setlength{\belowcaptionskip}{-0.5em}
\def\columnseprulecolor{\color{white!50!black}}

%定理环境
\theoremstyle{plain}
\newtheorem{theorem}{定理}[subsection]
\newtheorem{definition}{定义}[section]
\newtheorem{lemma}[theorem]{引理}
\newtheorem{corollary}[theorem]{推论}
\newtheorem{proposition}[theorem]{命题}

\theoremstyle{definition}
\newtheorem{example}[theorem]{例}
\newtheorem{circum}[theorem]{情形}

\newenvironment{proofs}[1][\small\proofname]{\begin{pf}[breakable, enhanced jigsaw]\begin{proof}[#1]\small\kai}{\end{proof}\end{pf}}
%\newenvironment{solution}{\begin{proofs}[\small\textit{\yan 解}]\small\renewcommand{\qedsymbol}{$\circledS$}}{\end{proofs}}
\renewcommand{\proofname}{\yan{证明}}

\newenvironment{twoc}{\vspace{-11pt}\begin{multicols}{2}}{\end{multicols}\vspace{-9pt}}
%颜色命名
\definecolor{meihong}{rgb}{0.85,0.2,0.47}
\definecolor{bali}{rgb}{0.2,0.6,0.78}
\definecolor{qinglv}{rgb}{0,0.35,0.32}
\newcommand{\colors}[1]{\color{#1!75!black}}
%tbox环境
\newtcolorbox{pr}[2][]{colback=black!5!white,colframe=white!75!black,fonttitle=\sffamily\wen\bfseries,title=#2,#1}
\newtcolorbox[use counter=definition,number within=subsection]{defi}[2][]{colback=bali!5!white,colframe=bali!75!black,fonttitle=\sffamily\wen\bfseries,title=定义~\thetcbcounter. #2,#1}
\newtcolorbox[auto counter,number within=section]{compl}[2][]{colback=bali!5!white,colframe=bali!65!black,fonttitle=\sffamily\wen\bfseries,label=#2,title=电路部件~\thetcbcounter. #2,#1, fontupper=\kai, fontlower=\kai}
\newtcolorbox[use counter=theorem,number within=subsection]{theo}[2][]{colback=meihong!5!white,colframe=meihong!75!black,fonttitle=\sffamily\wen\bfseries,fontupper=\run,title=结论~\thetcbcounter. #2,#1}
\newtcolorbox[use counter=definition,number within=subsection]{defil}[2][]{colback=bali!5!white,colframe=bali!75!black,fonttitle=\sffamily\wen\bfseries,label=#2,title=定义~\thetcbcounter. #2,#1}
\newtcolorbox[use counter=theorem,number within=subsection]{theol}[2][]{colback=meihong!5!white,colframe=meihong!75!black,fonttitle=\sffamily\wen\bfseries,fontupper=\run,label=#2,title=结论~\thetcbcounter. #2,#1}
\newtcolorbox[auto counter,number within=section]{note}[2][]{colback=qinglv!5!white,colframe=qinglv!75!black,breakable, enhanced jigsaw,fonttitle=\sffamily\wen\bfseries,title=注~\thetcbcounter. #2,#1}
\newtcolorbox{prenote}[2][]{colback=gray!5!white,colframe=gray!50!black,breakable, enhanced jigsaw, fonttitle=\sffamily\wen\bfseries,fontupper=\small\kai,title=#2,#1}
\newtcolorbox{pf}[1][]{colback=black!5!white,colframe=white!75!black, fontupper=\small\kai,#1}
%\newcommand{\mybox}[1]{\tikz[baseline=(MeNode.base)]{\node[rounded corners, fill=gray!20](MeNode){#1};}}

%代码环境
\lstset{
	xleftmargin=3em, xrightmargin=1em, 
	breaklines,                                 % 自动将长的代码行换行排版
	extendedchars=false,                        % 解决代码跨页时，章节标题，页眉等汉字不显示的问题
	rulecolor=\color[rgb]{0.8,0.8,0.8},         % 设置代码框颜色
	backgroundcolor=\color[rgb]{0.96,0.96,0.96},% 背景颜色
	keywordstyle=\colors{bali}\bfseries,        % 关键字颜色
	identifierstyle=\color{black},              % 普通标识符颜色
	commentstyle=\rm\kai\color{gray},          	% 注释颜色
	stringstyle=\colors{meihong},      			% 字符串颜色
	showstringspaces=false,                     % 不显示字符串内的空格
	numbers=left,                               % 显示行号
	numberstyle=\tiny,              			% 设置数字字体
	basicstyle=\linespread{1}\tt,               % 设置基本字体
	captionpos=t,                               % title在上方(在bottom即为b)
	frame=single,                               % 设置代码框形式
	showtabs=false, 
	numbersep=15pt, 
	framesep=1em, 
	language=C++, 
	columns=flexible, 
	tabsize=4, 
	gobble=4,
}
\lstdefinestyle{intro}
	{rulecolor=\color{bali!75!black}, backgroundcolor=\color{bali!5!white}, keywordstyle=\color{bali!50!black}\bfseries, morecomment=[s][\tt\bfseries\colors{bali}]{<-}{->}, }
\lstdefinestyle{qintro}
	{rulecolor=\color{bali!75!black}, backgroundcolor=\color{bali!5!white}, keywordstyle=\color{qinglv!50!black}\bfseries, morecomment=[s][\tt\bfseries\colors{qinglv}]{<-}{->}, }
\lstdefinestyle{notec}
	{xleftmargin=3.5em, xrightmargin=2.5em, rulecolor=\color{qinglv!75!black}, backgroundcolor=\color{qinglv!5!white}, keywordstyle=\color{qinglv!50!black}\bfseries, morecomment=[s][\tt\bfseries\colors{qinglv}]{<-}{->}, }
\lstdefinestyle{output}
	{rulecolor=\color{white!75!black}, backgroundcolor=\color{white!5!black}, language={}, basicstyle=\linespread{1}\color{white!90!black}\mono\wen, identifierstyle=\linespread{1}\color{white!90!black}\mono, morecomment=[s][\it]{<-}{->}, showspaces=false, basewidth=0.6em}

%定义格式记号
\newcommand{\hang}[1][1]{\hangafter 1 \hangindent #1em}
\newcommand{\den}[2][]{\begin{defi}{#1}\kai #2\end{defi}}
\newcommand{\din}[2][]{\begin{theo}{#1}\run #2\end{theo}}
\newcommand{\de}[2][]{\begin{defil}{#1}\kai #2\end{defil}}
\newcommand{\di}[2][]{\begin{theol}{#1}\run #2\end{theol}}
\newcommand{\dep}[3][]{\begin{defi}{#1\page{#2}}\kai #3\end{defi}}
\newcommand{\dip}[3][]{\begin{theo}{#1\page{#2}}\run #3\end{theo}}
\newcommand{\zhu}[2][]{\begin{note}{#1}\xiu #2\end{note}}
\newcommand{\tboba}[1]{\textbf{\kai\color{bali!75!black}#1}}
\newcommand{\mboba}[1]{\kai\symbf{\color{bali!75!black}#1}}
\newcommand{\tbome}[1]{\textbf{\run\color{meihong!75!black}#1}}
\newcommand{\mbome}[1]{\run\symbf{\color{meihong!75!black}#1}}
\newcommand{\tboqi}[1]{\textbf{\xiu\color{qinglv!75!black}#1}}
\newcommand{\mboqi}[1]{\xiu\symbf{\color{qinglv!75!black}#1}}

%定义算符
\def\upint{\mathchoice%
	{\mkern13mu\overline{\vphantom{\intop}\mkern7mu}\mkern-20mu}%
	{\mkern7mu\overline{\vphantom{\intop}\mkern7mu}\mkern-14mu}%
	{\mkern7mu\overline{\vphantom{\intop}\mkern7mu}\mkern-14mu}%
	{\mkern7mu\overline{\vphantom{\intop}\mkern7mu}\mkern-14mu}%
  \int}
\def\lowint{\mkern3mu\underline{\vphantom{\intop}\mkern7mu}\mkern-10mu\int}
\newcommand*{\dif}{\mathop{}\!\symrm{d}}
\newcommand*{\e}{\symrm{e}}
\renewcommand{\i}{\symrm{i}}
\newcommand*{\R}{\mathbb{R}}
\newcommand{\dint}[1][]{\displaystyle{\int #1}}
\newcommand*{\page}[1]{\hfill P$_\text{#1}$}

%标题、作者、日期
\title
{
	\textbf{计算机程序设计基础（C++）}\textit{知识与方法}
}
\author{\zihao{5} T$^\text{T}$T}
\date{\zihao{5}\kai \today}
%----------------------------------------------------------
\begin{document}

\maketitle
\begin{multicols}{2}
	\begin{flushleft}
		\tableofcontents
	\end{flushleft}
\end{multicols}

\newpage
%----------------------------------------------------------
\section{类和对象}

\subsection{面向对象的程序设计}
\begin{twoc}

C语言程序设计是\textbf{面向过程的程序设计}，其可以概括为：
\begin{itemize}[leftmargin=6em, itemindent=-3em]
	\item 范式：程序 $=$ 算法 $+$ 数据结构；
	
	\item 思想：（1）将程序看作一个“事件”；\\
	（2）按照事件发展的过程将“程序”分解为多个子过程（函数）；\\
	（3）将每个过程转写为算法（函数）；

	\item 特点：（1）以算法（函数）为中心；\\
	（2）\tbome{算法与数据分离}；\\
	（3）数据都是公用的，一个函数可以使用任何一组数据，一组数据又能被多个函数所使用；

	\item 核心问题：算法（函数）设计和数据定义。
\end{itemize}

\noindent 而C++语言程序设计是\textbf{面向对象的程序设计}，其可以概括为：

\begin{itemize}[leftmargin=6em, itemindent=-3em]
	\item 范式：程序 $=$ 对象 $+$ 消息；
	
	\item 思想：（1）任何系统都是有若干对象组成；\\
	（2）对象间通过消息作用构成一个有序系统（软件）；\\
	（3）程序以数据（对象）为中心；
	
	\item 对象两要素：属性（数据）和行为（方法/函数）；
	
	\item 特点：\tbome{数据和函数捆绑}，即属性和行为是对象不可分两特征；
	
	\item 核心问题：对象的设计与封装。
\end{itemize}

\end{twoc}
\subsection{对象的定义与访问}

\de[对象、类]{
	\hang 任何具备属性（attribute）和行为（behavior）两种要素的事物都可看成\tboba{对象（object）}，对象是属性（数据）和行为（函数）的\textbf{封装}。
	
	一系列对象的共同特征的描述称为一个\tboba{类（class）}。
}

\begin{twoc}
\subsubsection{类与对象的定义}

类是对象的\textbf{抽象（abstraction）}，对象是类的\textbf{实例（instance）}。类与对象的关系类似于结构体类型和结构体变量的关系。在程序设计中，往往先声明结构体类型，再用它去定义若干结构体变量；同样，往往先声明类，再用类定义对象。类是抽象的，不占用内存；对象是具体的，占用存储空间。

类声明的基本格式为（注意分号）：
\begin{lstlisting}[style=intro]
	class <-类名->
	{
	public:
		/* 公用数据与函数的定义或声明 */
	private:
		/* 私有数据与函数的定义或声明 */
	};
\end{lstlisting}
声明了类后，用已经声明的类来定义对象的基本格式为：
\begin{lstlisting}[style=intro]
	<-类名-> <-对象名->;
\end{lstlisting}

其中，\texttt{private}和\texttt{public}称为\tboba{成员访问限定符}，缺省限定符为\texttt{private}。\texttt{private}后的数据与函数只能被类内成员函数调用，\texttt{public}后的数据与函数可以在类外调用。通常在\texttt{public}后只留类内数据的访问接口。例如
\begin{lstlisting}
	#include<iostream>
	using namespace std;
	class Time				//类的声明
	{
	public:
		void set_time();
		void show_time();
	private:
		int hour;
		int minute;
		int second;
	};
	int main()
	{
		Time t1;			//对象定义
		t1.set_time();		//消息调用
		t1.show_time();
		Time t2;			//对象定义
		t2.set_time();		//消息调用
		t2.show_time();
	}
\end{lstlisting}
类的成员函数可以在类之外定义，即
\begin{lstlisting}
	class Time
	{
	public:
		void show_time()
		{
			cout<<hour<<endl;
			cout<<minute<<endl;
			cout<<second<<endl;
		}
	private:
		int hour;
		int minute;
		int second;
	};
\end{lstlisting}
等价于
\begin{lstlisting}
	class Time
	{
	public:
		void show_time();
	private:
		int hour;
		int minute;
		int second;
	};
	void Time::show_time()
	{
		cout<<hour<<endl;
		cout<<minute<<endl;
		cout<<second<<endl;
	}
\end{lstlisting}
同样要注意分号的使用。

\zhu[inline函数]{
	\hang 函数调用时需要一定的时间和空间的开销。C++提供一种提高效率方法，即在编译时将被调函数的代码直接展开到主调函数中，而不是在函数执行时将流程转出去。这种能嵌到主调函数中函数称内置函数。

	\hang 申明为内置函数只需在函数首行的左端加一个关键字inline即可。在类体中定义的成员函数，如果没有循环递归控制结构，就会被编译系统自动视为inline函数，因此类内无需用inline申明内置成员函数，而类外则不能省去inlien。
}

\subsubsection{对象成员的访问}
访问对象中的\texttt{public}成员有三种方法，分别是：
\begin{itemize}
	\item 通过对象名和成员运算符访问，如
	\begin{lstlisting}[xleftmargin=1em,
		moreemph={Time}, emphstyle=\colors{qinglv}, 
		moreemph={[2]{today}}, emphstyle={[2]\it\ttfamily},]
	Time today;
	today.set_time();
	\end{lstlisting}
	\item 通过指向对象的指针访问，即
	\begin{lstlisting}[xleftmargin=1em, 
		moreemph={Time}, emphstyle=\colors{qinglv}, 
		moreemph={[2]{today, ptime}}, emphstyle={[2]\it\ttfamily},]
	Time today;
	Time *ptime = &today;
	ptime->set_time();
	\end{lstlisting}
	\item 通过对象的引用变量访问，即
	\begin{lstlisting}[xleftmargin=1em, 
		moreemph={Time}, emphstyle=\colors{qinglv}, 
		moreemph={[2]{today, anyday}}, emphstyle={[2]\it\ttfamily},]
	Time today;
	Time &anyday = today;
	anyday.set_time();
	\end{lstlisting}
\end{itemize}

\end{twoc}

\subsection{类的构造函数与析构函数}


\subsubsection{构造函数}
\de[构造函数]{
	\tboba{构造函数（constructor）}是与其所在类同名的一个特殊\texttt{public}成员函数，在定义对象时自动执行，专门用来处理类下对象的初始化。
}
若没有定义，则编译器在类中添加一个空构造函数，仍调用但不执行任何操作。

自定义构造函数有以下类型：
\begin{itemize}
	\item \tboba{无参数构造函数}，使得每个新对象都有相同的初始值，定义格式为：
	\begin{lstlisting}[style=intro, xleftmargin=1em]
	<-类名（构造函数名）->()
	{
		/* 对数据变量初始化等 */
	}
	\end{lstlisting}
	其中函数体也可以加入其他操作，但这可能会降低代码的复用性。
	\item \tboba{含参数构造函数}，使得每个新对象都依据定义时的参数取不同的初始值，此时类的声明与对象的定义基本格式为：
	\begin{lstlisting}[style=intro, xleftmargin=1em]
	class <-类名->
	{
	public:
		<-类名（构造函数名）->(<-类型1-> <-形参1->, <-类型2-> <-形参2->, …)
		{
			/* 用形参对数据变量初始化等 */
		}
	private:
		/* 数据变量表 */
	}
	int main()
	{
		<-类名-> <-对象名-> (<-实参1->, <-实参2->, …);			//用类定义对象同时初始化
	}
	\end{lstlisting}
	即在定义对象时直接在后面加上参数。
\end{itemize}

含参数的构造函数可以\tboba{重载}，即给一个函数名以不同的函数体以便对类对象提供不同的初始化方法。但对象构建时只能执行其一，此时只能用参数表区分，因此每个函数体的参数个数或参数类型必须有所不同，即根据定义时给的参数表确定执行的函数体。例如：
\begin{lstlisting}[
	moreemph={Time}, emphstyle=\colors{qinglv}, 
	moreemph={[2]{h, m, s, hour, minute, second, nowtime1, nowtime2}}, emphstyle={[2]\it\ttfamily},]
	class Time
	{
	public:
		Time(int h, int m, int s) { hour = h, minute = m, second = s; }
		Time() { hour = 24, minute = 60, second = 60; }
	private:
		int hour, minute, second;
	};
	int main()
	{
		Time nowtime1;                      // 初始化为 24，60，60
		Time nowtime2(20, 26, 3);           // 初始化为 20，26，3
	}
\end{lstlisting}
C++支持将格式相近的构造函数体合并，即使得参数带有默认值。例如，上例中构造函数即可写成：
\begin{lstlisting}[
	moreemph={Time}, emphstyle=\colors{qinglv}, 
	moreemph={[2]{h, m, s, hour, minute, second, nowtime1, nowtime2}}, emphstyle={[2]\it\ttfamily}, ]
	Time(int h = 24, int m = 60, int s = 60) { hour = h, minute = m, second = s; }
\end{lstlisting}
默认参数的构造函数允许形参没有实参输入，因此不能再在对应位置重载构造函数，如上面的构造函数与任意参数数量不多于三个的函数体都不兼容。

C++对数据变量初始化的函数体提供了简写形式，即用冒号引出\tboba{参数初始化表}的写法。其基本格式为：
\begin{lstlisting}[style=intro]
	<-类名（构造函数名）->(<-类型1-> <-形参1->, <-类型2-> <-形参2->, …)
		: <-成员变量1->(<-初始值1->), <-成员变量2->(<-初始值2->), … 
		{}
\end{lstlisting}
其中成员变量的初始值是形参的表达式，通常就是形参本身；形参可以带有自己的默认值。例如，下面写法与上例等价：
\begin{lstlisting}[
	moreemph={Time}, emphstyle=\colors{qinglv}, 
	moreemph={[2]{h, m, s, hour, minute, second, nowtime1, nowtime2}}, emphstyle={[2]\it\ttfamily}, ]
	Time(int h = 24, int m = 60, int s = 60): hour(h), minute(m), second(s) {}
\end{lstlisting}

\zhu[关于构造函数的几点说明]{
	（1）构造函数必须声明为\texttt{public}成员；

	\hang[2]（2）构造函数的调用时间为对象进入作用域、对象的生命周期开始时刻，只能由编译器根据对象产生以隐藏方式调用，不能由程序代码直接调用；
	
	\hang[2]（3）构造函数没有返回值，在声明和定义时不需要注明void返回类型；其函数体可以包含包括cin、cout语句在内的任何内容，但不提倡在构造函数中加入与初始化无关的操作；
	
	（4）当且仅当用户没有定义构造函数，编译器自动提供缺省的无参数构造函数，其函数体为空。
}

\subsubsection{析构函数}

\de[析构函数]{
	\tboba{析构函数（destructor）}是以其所在类名称加上波浪线 $\sim$ 前缀为名的一个特殊\texttt{public}成员函数，在对象生命期结束时自动执行，专门用来执行类下对象的善后工作。
}
\zhu[关于析构函数的几点说明]{
	\hang[2]（1）析构函数必须声明为public成员；

	\hang[2]（2）析构函数的调用时间为对象离开作用域或被删除等对象的生命期结束时刻，只能由编译器根据对象回收以隐藏方式调用，不能由程序代码直接调用；

	\hang[2]（3）析构函数没有返回值和参数，在声明和定义时不需要注明void返回类型，且一个类只有一个析构函数，不能重载；其函数体可以包含包括cin、cout语句在内的任何内容，建议析构函数进行对象回收时的内存清理等结束工作；

	（4）当且仅当用户没有定义析构函数，编译器自动提供缺省的析构函数，其函数体为空。
}
\zhu[运算符new与delete]{
	\hang new运算符用于为构建对象申请内存空间，\texttt{new CLASS}申请一块大小为类\texttt{CLASS}的对象大小的内存空间，同时对其按类\texttt{CLASS}调用构造函数。

	\hang delete运算符用于释放对象的内存空间，\texttt{delete pCLASS}释放\texttt{pCLASS}指向的对象的内存空间，同时对其按用new构建时的类\texttt{CLASS}调用析构函数。
}

\subsubsection{拷贝构造函数}
对象的\tboba{拷贝}，是指用一个对象的数据快速地产生出多个相同对象，可看做是对象的定义与赋值过程的结合。对象拷贝的基本格式可写成 \lstinline[style=intro]{<-类名->  <-新对象->(<-原对象->);} ，也可写成赋值形式的 \lstinline[style=intro]{<-类名->  <-新对象->  =  <-原对象->;} 。

发生拷贝时，新对象的定义不会调用构造函数，而会调用\tboba{拷贝构造函数}，其声明格式为：
\begin{lstlisting}[style=intro, moreemph={object}, emphstyle=\it\ttfamily, ]
	<-类名（拷贝构造函数名）-> (const <-类名-> &object);
\end{lstlisting}
其中形参\texttt{\textit{object}}是本类的一个对象。用同样的方式可以自定义拷贝构造函数，但由于参数表已经确定，拷贝构造函数不能重载。事实上，拷贝构造函数就是构造函数的以类的对象的引用为参数的一个重载。

\zhu[隐式拷贝]{
	除了在\tboqi{用类的一个对象去初始化该类的另一个新定义的对象}时会调用拷贝构造函数外，在\tboqi{类的对象以值被传入函数}、\tboqi{具名对象以值被函数返回}这三种情况下，还会发生调用拷贝构造函数的\tboqi{隐式拷贝}。下面是一个例子，其中\texttt{\textit{today}}作为实参传递给形参\texttt{\textit{A}}，\texttt{\textit{B}}作为返回值传递出函数体（因为执行函数和执行赋值表达式是前后两步，此时只能传递给一个临时变量\texttt{\textit{temp}}）都是调用拷贝构造函数的隐式拷贝。
	\vspace{9\baselineskip}
}
\vspace{-10\baselineskip}
\begin{lstlisting}[style=notec, moreemph={Date}, emphstyle=\colors{qinglv}, moreemph={[2]{A, B, today}}, emphstyle={[2]\it\ttfamily}, ]
	Date func(Date A)
	{
		Date B(A);
		return B;					// 此处有返回值传出
	}
	void main()
	{
		Date today(1,1,1900);
		today = func(today);		// 此处有参数值传入
	}
\end{lstlisting}
\vspace{\baselineskip}

\subsection{对象的调用形式}

\subsubsection{对象的浅拷贝问题}

若类的数据域中有指针域，将一个对象的各成员值赋给另一个对象的各成员时，指针类成员拷贝的只是地址，使得不同对象中的指针成员指向同一块内存，造成了隐含的空间共享，破坏了对象之间的独立性，就称为\tboba{浅拷贝}。

解决浅拷贝问题，需要重新编写拷贝构造函数，以对指针类成员重新分配空间，称为进行\tboba{深拷贝}。

例如，对下面的类~\lstinline[moreemph={Strings}, emphstyle=\colors{qinglv}, moreemph={[2]{length, str, s}}, emphstyle={[2]\it\ttfamily}, ]|Strings|：
\begin{lstlisting}[moreemph={Strings}, emphstyle=\colors{qinglv}, moreemph={[2]{length, str, s}}, emphstyle={[2]\it\ttfamily}, ]
	class Strings
	{
	public:
		Strings(char *s);
		~Strings();
		void Print();
		void Set(char *s);
	private:
		int length;
		char *str;
	};
\end{lstlisting}

\noindent 直接使用默认的缺省拷贝构造函数，指针~\lstinline[moreemph={Strings}, emphstyle=\colors{qinglv}, moreemph={[2]{length, str, s}}, emphstyle={[2]\it\ttfamily}, ]|str|~会出现浅拷贝问题。因此，需要重新编写拷贝构造函数：
\begin{lstlisting}[moreemph={Strings}, emphstyle=\colors{qinglv}, moreemph={[2]{length, str, s, p}}, emphstyle={[2]\it\ttfamily}, ]
	class Strings
	{
	public:
		Strings(char *s);
		Strings(Strings &p);
		~Strings();
		void Print();
		void Set(char *s);
	private:
		int length;
		char *str;
	};
	Strings::Strings(Strings &p)		// 新的拷贝构造函数
	{
		length = strlen(p.str);
		str = new char[length + 1];
		strcpy(str, p.str);
	}
\end{lstlisting}

\subsubsection{对象数组}
静态构建对象数组的基本格式为：
\begin{lstlisting}[style=intro]
	<-类名-> <-数组名->[<-数组长度->] = { <-初始参数表-> };
\end{lstlisting}
其中初始参数表中，数组各项的初始参数表用逗号隔开，写成调用构造函数的形式，即写成
\begin{lstlisting}[style=intro]
	<-类名-> <-数组名->[<-数组长度->] = {
		<-类名（构造函数名）->(<-参数表1->), 
		<-类名（构造函数名）->(<-参数表2->), … 
	};
\end{lstlisting}

动态构建对象数组使用~\lstinline|new|~运算符：
\begin{lstlisting}[style=intro]
	<-类名-> * <-指针名-> = new <-类名->[<-数组长度->];
\end{lstlisting}
其指针指向数组的第0个对象的首地址。

要释放使用~\lstinline|new|~运算符动态构建的对象数组，则需要对应地使用：
\begin{lstlisting}[style=intro]
	delete [] <-指针名->;
\end{lstlisting}

\zhu[对象数组的释放]{
	直接使用~\lstinline|delete <-指针名->;|~也可以释放对象。但是，在释放对象数组时，此语句只能释放对象数组的首对象，没有对后面的对象执行析构函数；而失去首对象后，后面的对象也无法再以数组形式访问。
}

\subsubsection{对象指针}

访问对象中成员变量的指针与一般指向结构体成员指针类似。成员访问限定符并不能限制通过指针访问类的\texttt{private}成员变量。

访问对象中成员函数的指针指向对象中某个成员函数的入口地址，其和普通函数的指针变量定义方法不同，定义形式为：
\begin{lstlisting}[style=intro]
	<- 返回值数据类型 -> (<-类名->::*<-指针变量名->)(<-参数表->);
\end{lstlisting}
赋值形式为：
\begin{lstlisting}[style=intro]
	<-指针变量名-> = &<-类名->::<-成员函数名->;
\end{lstlisting}
调用形式为：
\begin{lstlisting}[style=intro]
	……(<-对象名->.*<-指针变量名->)(<-参数表->)……
\end{lstlisting}

成员函数指针的使用要注意三个方面的匹配，即
\begin{itemize}
	\item 定义函数指针使用的参数表（类型和数目）与成员函数参数表匹配；
	\item 函数指针的返回值类型与成员函数返回值匹配；
	\item 函数指针所在的类与成员函数所在的类匹配。
\end{itemize}
同样，成员访问限定符并不能限制通过指针访问类的\texttt{private}成员函数。

\zhu[成员函数指针的对象绑定]{
	在面向对象的程序设计，也即C++程序设计中，函数总是与类绑定的。类的成员函数通过\texttt{\textit{this}}指针调用对象中的数据，而其本身并不与对象绑定。因此，成员函数指针在定义乃至赋值阶段都不与对象绑定，只有在调用时才通过\texttt{\textit{this}}指针的值与对象绑定。在定义、赋值时，函数指针都由类限定，只有调用时才由对象限定。
}

\zhu[\texttt{\textit{this}}指针]{
	每个成员函数都包含一个特殊的指针，即\texttt{\textit{this}}。\texttt{\textit{this}}的值是当前被调用的成员函数所在对象的起始地址。执行~\lstinline[moreemph={Strings}, emphstyle=\colors{qinglv}, moreemph={[2]{object}}, emphstyle={[2]\it\ttfamily}, ]|object.function();|~语句时，即将\texttt{function()}的\texttt{\textit{this}}赋为\texttt{\&\textit{object}}。\texttt{\textit{this}}指针也可以作为返回值的构成部分，传出一个对象或其地址，如下面的例子。
	\vspace{15.2\baselineskip}
}
\vspace{-16.2\baselineskip}
\begin{lstlisting}[style=notec, moreemph={Date}, emphstyle=\colors{qinglv}, moreemph={[2]{this, today}}, emphstyle={[2]\it\ttfamily}, ]
	class Date
	{
	public:
		Date & add_day();
		void Print();
	private:
		/* 日期数据的成员变量 */
	};
	Date & Date::add_day()
	{
		/* 实现日期加一日功能的代码 */
		return *this;
	}
	void main()
	{
		Date today(1,1,1900);
		today.add_day.Print();
				// 此处 today.add_day 传出一个对象，接着调用该对象的 Print() 函数
	}
\end{lstlisting}
\vspace{\baselineskip}

\newpage
\subsection{共用数据的保护}

\subsubsection{const常类型}

\begin{table}[ht!]
	\begin{center}
	\caption{用const进行变量或函数的定义或声明}
	\begin{tabular}{p{50pt}<{\centering}p{225pt}<{\raggedright}p{175pt}<{\raggedright}}
		\toprule
		\textbf{类型} & \textbf{语句} & \textbf{说明} \\
		\midrule
		常变量 & \lstinline[style=intro]|const <-数据类型->   <-变量名->  = <-初值->;| 
		& 定义自身内容不可更改的普通变量 \\
		\specialrule{0.3pt}{2.5pt}{2.5pt}
		常指针 & \lstinline[style=intro]|const <-数据类型->  * <-指针变量名->;| 
		& 定义\textbf{指向内存空间不可更改}、自身指向地址可以更改的指针变量 \\
		~ & \lstinline[style=intro]|<-数据类型->  * const <-指针变量名->   = <-初值->;| 
		& 定义\textbf{指向地址不可更改}的指针变量 \\
		\specialrule{0.3pt}{2.5pt}{2.5pt}
		常对象 & \lstinline[style=intro]|<-类名->  const <-对象名->(<-参数表->);| 
		& 定义自身内容不可更改的对象，其必须通过构造函数进行初始化；除了隐式调用的构造和析构函数以外，\textbf{不能调用常对象的非const成员函数} \\
		\specialrule{0.3pt}{2.5pt}{2.5pt}
		常对象指针 & \lstinline[style=intro]|const <-类名->  * <-指针变量名->;| 
		& 定义\textbf{指向的对象内存空间不可更改}，自身指向地址可以更改的类指针变量 \\
		~ & \lstinline[style=intro]|<-类名->  * const <-指针变量名->   = <-初值->;| 
		& 定义\textbf{指向的地址不可更改}的类指针；其指针值始终保持为其初值，不可更改，即只能指向一个对象 \\
		\specialrule{0.3pt}{2.5pt}{2.5pt}
		常引用 & \lstinline[style=intro]|const <-类名->   & <-指针变量名->   = <-初值->;| 
		& 定义一个对象的只读引用 \\
		\specialrule{0.3pt}{2.5pt}{2.5pt}
		常成员变量 & 类声明中：\lstinline[style=intro]|const <-数据类型->   <-变量名->;| 
		& 定义自身内容不可更改的成员变量，其必须\textbf{通过参数初始化表赋初值} \\
		\specialrule{0.3pt}{2.5pt}{2.5pt}
		常成员函数 & 类声明中：\lstinline[style=intro]|<-返回值类型->   <-函数名->(<-参数表->)   const;| 
		& 声明一个函数体不能更改类成员变量的成员函数 \\
		~ & 类声明外：\lstinline[style=intro]|<-返回值类型->   <-类名->::<-函数名->(<-参数表->)    const {<-函数体->};| 
		& 定义一个函数体不能更改类成员变量的成员函数 \\
		\bottomrule
	\end{tabular}
	\vspace{-1em}
	\end{center}
\end{table}
\begin{table}[ht!]
	\begin{center}
	\caption{const对成员函数与成员变量作用的影响}
	\begin{tabular}{p{160pt}<{\centering}p{75pt}<{\centering}p{100pt}<{\centering}p{100pt}<{\centering}}
		\toprule
		\textbf{数据成员类型} & \textbf{操作} & \textbf{非const成员函数} & \textbf{const成员函数} \\
		\midrule
		\multirow{2}*{非const对象的非const成员} & 引用（读） & 可以 & 可以 \\
		~ & 更改（写） & 可以 & 不可以 \\
		\multirow{2}*{非const对象的const成员} & 引用（读） & 可以 & 可以 \\
		~ & 更改（写） & 不可以 & 不可以 \\
		\multirow{2}*{const对象的成员} & 引用（读） & 不可以 & 可以 \\
		~ & 更改（写） & 不可以 & 不可以 \\
		\bottomrule
	\end{tabular}
	\end{center}
\end{table}

\zhu[如何利用const共用数据保护机制]{
	C++类对象的赋值、拷贝往往被常引用替代：

	\hang[2]（1）为提高效率可通过引用来传递类对象，但引用会共享空间，若要确保传入的对象内容不被改变，可以使用常引用；

	\hang[2]（2）如果返回值是一个对象，也可以通过返回引用来提高效率，若要确保返回的对象内容不被改变，可以返回常引用；

	\hang[2]（3）如果要确保对象内容不被改变，比常对象更好的方法是对象的常引用。

	如果要确保对象的成员内容不被改变，比常对象和常成员变量更好的方法是定义常成员函数，用常成员函数作为对象属性的只读访问接口；但需注意，对于常对象，除了隐式调用的构造和析构函数以外，不能调用常对象的非const成员函数。
}

\subsubsection{静态成员}

为实现类的不同成员之间的通信，C++引入了类的\tboba{静态成员}。静态成员由类的所有对象共享，常用于描述类的属性。

定义类的静态成员的基本格式为：
\begin{lstlisting}[style=intro]
	class <-类名->
	{
		……
		static <-数据类型-> <-变量名->;
		……
	};
\end{lstlisting}

类的静态成员属于整个类，不属于任何一个具体对象，所以它们和全局变量一样，在所有本类对象产生之前就被分配。类的静态成员的初始化应当独立于类的对象的初始化进行。

例如，对包含年月日数据的~\lstinline[moreemph={Date}, emphstyle=\colors{qinglv}, moreemph={[2]{length, str, s}}, emphstyle={[2]\it\ttfamily}, ]|Date|~类，要将默认日期定义为静态成员，有三种定义方式：
\begin{itemize}
\item 直接使用\texttt{public}静态成员变量，定义为
\begin{lstlisting}[xleftmargin=1em,
	moreemph={Date}, emphstyle=\colors{qinglv}, %
	moreemph={[2]{y, m, d, dy, dm, dd, yi, mi, di}}, emphstyle={[2]\it\ttfamily}, ]
	class Date
	{
	private:
		int y, m, d;
	public:
		static int dy, dm, dd;
		Date(int yi, int mi, int di) : y(yi), m(mi), d(di) {}
	};
\end{lstlisting}
这样就可以直接用
\begin{lstlisting}[xleftmargin=1em,
	moreemph={Date}, emphstyle=\colors{qinglv}, %
	moreemph={[2]{y, m, d, dy, dm, dd, yi, mi, di}}, emphstyle={[2]\it\ttfamily}, ]
	int Date::dy = 1900;
	int Date::dm = 1;
	int Date::dd = 1;
\end{lstlisting}
初始化三个静态变量；
\item 使用\texttt{public}静态对象封装上面的三个变量，定义为
\begin{lstlisting}[xleftmargin=1em,
	moreemph={Date}, emphstyle=\colors{qinglv}, %
	moreemph={[2]{y, m, d, dy, dm, dd, yi, mi, di, defaultDate}}, emphstyle={[2]\it\ttfamily}, ]
	class Date
	{
	private:
		int y, m, d;
	public:
		static Date defaultDate;
		Date(int yi, int mi, int di) : y(yi), m(mi), d(di) {}
	};
\end{lstlisting}
这样则用
\begin{lstlisting}[xleftmargin=1em,
	moreemph={Date}, emphstyle=\colors{qinglv}, %
	moreemph={[2]{y, m, d, dy, dm, dd, yi, mi, di, defaultDate}}, emphstyle={[2]\it\ttfamily}, ]
	Date Date::defaultDate(1900, 1, 1);
\end{lstlisting}
初始化这个静态成员对象；
\item 定义\tboba{静态成员函数}专门用来初始化静态对象，即 
\begin{lstlisting}[xleftmargin=1em,
	moreemph={Date}, emphstyle=\colors{qinglv}, %
	moreemph={[2]{y, m, d, dy, dm, dd, yi, mi, di, sy, sm, sd, defaultDate}}, emphstyle={[2]\it\ttfamily}, ]
	class Date
	{
	private:
		int y, m, d;
		static Date defaultDate;
	public:
		Date(int yi, int mi, int di) : y(yi), m(mi), d(di) {}
		static void setdefault(int sy, int sm, int sd)
		{
			defaultDate.y = sy;
			defaultDate.m = sm;
			defaultDate.d = sd;
		}
	};
\end{lstlisting}
这样调用函数即可完成初始化。
\end{itemize}

\zhu[静态成员的特性]{
	\hang[2]（1）由于静态成员实质上是全局变量，所以不随对象产生而分配，也不随对象销毁而释放，在类声明时已经分配内存，在~\lstinline|main()|~函数结束后才释放；
	
	\hang[2]（2）静态成员为所有类对象所共有，每一个类对象的成员函数都可以访问它们，但在类外访问\texttt{public}静态成员变量时，一般使用「\lstinline[style=qintro]|<-类名->::<-静态成员名->|」方式，因为静态成员属于整个类，而不是某个具体对象；

	（3）静态数据成员的初始化不能在构造函数、初始化参数表中进行，只能在类外进行；

	（4）静态成员函数没有\texttt{\textit{this}}指针，不能访问非静态数据成员。
}

\subsection{类的继承与派生}

\subsubsection{派生类的声明}

声明派生类的一般形式为：
\begin{lstlisting}[style=intro]
	class <-派生类名-> : <-继承方式-> <-基类名->
	{
		// 新增加的成员
	};
\end{lstlisting}
其中「继承方式」分为\texttt{public}、\texttt{protected}、\texttt{private}，可以省略，缺省值为\texttt{private}。

\begin{table}[ht!]
	\begin{center}
	\caption{基类成员在派生类中的访问权限}\label{Tab: 基类成员在派生类中的访问权限}
	\begin{tabular}{p{80pt}<{\centering}|p{80pt}<{\centering}p{80pt}<{\centering}p{80pt}<{\centering}}
		\toprule
		\multirow{2}*{\textbf{继承方式}} & \multicolumn{3}{c}{\textbf{基类中成员访问限定}}\\[2pt] \cline{2-4}
		~ & \textbf{\texttt{public}} & \textbf{\texttt{protected}} & \textbf{\texttt{private}} \\
		\midrule
		\texttt{public} & \texttt{public} & \texttt{protected} & inaccessible \\
		\texttt{protected} & \texttt{protected} & \texttt{protected} & inaccessible \\
		\texttt{private} & \texttt{private} & \texttt{private} & inaccessible \\
		\bottomrule
	\end{tabular}
	\vspace{-1.5em}
	\end{center}
\end{table}
在派生类构造时，派生类会接受基类\textbf{除构造、析构函数外全部的成员}，改变其访问属性，同时增加新成员、进行同名屏蔽替换。例如，对下面的\texttt{CAnimal}类：
\begin{lstlisting}[moreemph={CAnimal, CPig}, emphstyle=\colors{qinglv}, %
	moreemph={[2]{animal, m_fweight, apig, m_fPorkWeight}}, emphstyle={[2]\it\ttfamily}, ]
	class CAnimal
	{
	public:
		void GetWeight() { cin >> m_fweight; }
	private:
		float m_fweight;
	};
\end{lstlisting}
其函数\texttt{GetWeight()}是public成员，可以在类外通过对象访问；但对其派生类\texttt{CPig}：
\begin{lstlisting}[moreemph={CAnimal, CPig}, emphstyle=\colors{qinglv}, %
	moreemph={[2]{animal, m_fweight, apig, m_fPorkWeight}}, emphstyle={[2]\it\ttfamily}, ]
	class CPig : private CAnimal
	{
	public:
		void GetPorkWeight() { cin >> m_fPorkWeight; }
	private:
		float m_fPorkWeight;
	};
\end{lstlisting}
由于继承方式是\texttt{private}，函数\texttt{GetWeight()}成为其private成员，在类外通过对象不能访问。

派生类的继承方式会限制基类成员在派生类中的访问级别，对基类中public与protected成员，可用~\lstinline[style=intro]|using <-基类名->::<-成员名->|~改变基类访问级别：
\begin{itemize}
	\item 在\texttt{public}下进行using声明的成员，可在派生类外通过对象访问，但不能用基类对象访问，如上面\texttt{CAnimal}类的派生类\texttt{CPig}，若改为：
\begin{lstlisting}[xleftmargin=1em, %
	moreemph={CAnimal, CPig}, emphstyle=\colors{qinglv}, %
	moreemph={[2]{animal, m_fweight, apig, m_fPorkWeight}}, emphstyle={[2]\it\ttfamily}, ]
	class CPig : private CAnimal
	{
	public:
		using CAnimal::GetWeight;		// 将函数 GetWeight() 用作 public 成员
		void GetPorkWeight() { cin >> m_fPorkWeight; }
	private:
		float m_fPorkWeight;
	};
\end{lstlisting}
	则其可以在类外通过对象访问，即下面第8行代码可以运行：
\begin{lstlisting}[xleftmargin=1em, %
	moreemph={CAnimal, CPig}, emphstyle=\colors{qinglv}, %
	moreemph={[2]{animal, m_fweight, apig, m_fPorkWeight}}, emphstyle={[2]\it\ttfamily}, ]
	#include <iostream>
	using namespace std;
	int main(void)
	{
		CAnimal animal;
		animal.GetWeight();
		CPig apig;
		apig.GetPorkWeight();
		apig.GetWeight();
	}
\end{lstlisting}
	此时，同时实现了访问本不可访问的\texttt{\textit{apig}.\textit{m\_fweight}}；

	\item 在\texttt{protected}下进行using声明的成员，可以继续派生下去；
	\item 在\texttt{private}下进行using声明的成员，不能在派生类外通过对象访问。
\end{itemize}

多级继承时，仍有按表~\ref{Tab: 基类成员在派生类中的访问权限}~确定的访问权限的演变。

\subsubsection{派生类的构造函数和析构函数}

派生类的构造函数不能继承，这是因为其构造函数不仅要考虑基类继承数据成员初始化，还应当考虑派生类所增加数据成员的初始化。编写派生类的构造函数时，\textbf{首先要通过参数初始化表调用基类的构造函数，对基类数据成员初始化}，然后再继续用参数初始化表初始化新增数据成员，或在函数体中初始化新增数据成员。

调用构造函数时，首先调用基类的构造函数，然后调用派生类的构造函数的剩余初始化部分。若有多级派生，在参数初始化表中只需调用直接基类的构造函数，构造对象时通过直接基类的构造函数先调用间接基类的构造函数，然后调用直接基类的构造函数，最后调用派生类的构造函数的剩余初始化部分。

\zhu[编写派生类构造函数的特殊情况]{
	（1）当不需要对派生类新增的成员进行任何初始化操作时，派生类构造函数的函数体可以为空，即构造函数是空函数。

	（2）当基类没有定义任何构造函数，或者只是定义了无参构造函数时，派生类构造函数可以不写基类构造函数调用，此时C++编译器将自动调用基类的无参构造函数（若无，则调用默认构造函数），无需传递参数；

	（3）C++11中，引入了\textbf{继承构造函数}语法，即用语句~\lstinline[style=notec]|using <-基类名->::<-基类名->|~直接将基类的构造函数作为派生类的构造函数，同时不能继承基类构造函数的默认值。
}

同样，派生类不能继承基类的析构函数，也需要通过派生类的析构函数去调用基类的析构函数；同时，可以在派生类中根据需要定义自己的析构函数，用来对派生类中所增加的成员进行清理工作，而基类成员的清理工作仍然由基类的析构函数负责。

在执行派生类的析构函数时，调用的顺序与构造函数正好相反：先执行派生类自己的析构函数，对派生类新增加的成员进行清理，然后调用基类的析构函数，对基类进行清理。

\subsubsection{多重继承的同名覆盖与虚基类}

一个派生类有两个或多个基类，派生类从两个或多个基类中继承所需的属性，这种写法称为\tboba{多重继承}，其一般格式为：
\begin{lstlisting}[style=intro]
	class <-派生类名-> : <-基类1继承方式-> <-基类1名->, ..., <-基类n继承方式-> <-基类n名->
	{
		// 新增加的成员
	};
\end{lstlisting}
多重继承的派生类的构造函数中，只需在参数初始化表中列出各直接基类构造函数即可。直接基类构造函数会按照参数初始化表中的顺序调用。

多重继承最常见的问题，是继承的成员同名产生的\textbf{二义性（ambiguity）}问题，即同一个成员名可能既可指向基类（可能还不止一个基类）中的成员，也可能指向派生类的新增成员。为此，成员的调用遵循\textbf{同名覆盖规则}，即如果在定义派生类对象的模块中通过对象名访问同名成员而不加修饰，则访问的是派生类的成员，即派生类优先原则。\label{同名覆盖规则}
\zhu[同名覆盖与函数重载]{成员函数只有在函数名和参数都相同才发生同名覆盖。只是函数名相同而参数不同为函数重载。}

多重继承的另一个问题，是同时有多级派生产生的\textbf{冗余性（redundancy）}问题，即如果一个派生类有多个直接基类，而这些直接基类又有一个共同的基类，则在最终的派生类中会保留该间接共同基类数据成员的多份同名成员。为此，可将基类作为\tboba{虚基类}进行派生，使在继承间接相同基类时只保留一份成员，即同名成员在内存中只有一份拷贝。虚基类声明的一般格式为：
\begin{lstlisting}[style=intro]
	class <-直接派生类名-> : virtual <-虚基类1继承方式-> <-虚基类1名->, ..., virtual <-虚基类n继承方式-> <-虚基类n名->, <-其他基类1继承方式-> <-其他基类1名->, ..., <-其他基类n继承方式-> <-其他基类n名->
	{
		// 新增加的成员
	};
\end{lstlisting}
虚基类的声明不是在最终的派生类中对直接基类做声明，而是\textbf{在各直接基类中对间接基类做声明}。为了保证虚基类在最终的派生类中只继承一次，应当在该基类的所有直接派生类中声明为虚基类，否则仍然会出现对基类的多次继承。

\newpage
\zhu[虚基类的初始化]{
	\hang[2]（1）如果在虚基类中定义了带参数的构造函数，则在其所有派生类（包括直接派生或间接派生的派生类）中，如果需要使用这一重载，都要通过\tboqi{构造函数的参数初始化表}对虚基类进行初始化，如：

	\vspace{8\baselineskip}

	\hang[2]　　其中，对虚基类的间接派生类，参数初始化表中须\tboqi{由其直接调用间接基类的有参构造函数}，因为各直接基类（上例B、C）调用虚基类的构造函数时可能会出现参数矛盾；同时，按语法，各直接基类（上例B、C）的构造函数调用也\tboqi{不能省略}，但编译器会忽略直接基类中对虚基类的构造函数的调用，即写为

	\vspace{3.7\baselineskip}

	\hang[2]（2）这些构造函数的调用遵循如下顺序：
	\begin{itemize}[leftmargin=3em]
		\item 虚基类的构造函数在非虚基类之前调用；
		\item 同一层包含多个虚基类，则按申明顺序调用；
		\item 若虚基类由非虚基类派生而来，则要先调用更高级别的基类构造函数，再遵循前两点的顺序。
	\end{itemize}
}
\vspace{-21\baselineskip}
\begin{lstlisting}[style=notec, name=VirBase, xleftmargin=4.5em]
	class A {
		A(int i){}
		/* 其他成员 */ };
	class B : virtual public A {
		B(int i) : A(i){}
		/* 其他成员 */ };
	class C : virtual public A {
		C(int i) : A(i){}
		/* 其他成员 */ };
\end{lstlisting}
\vspace{3.5\baselineskip}
\begin{lstlisting}[style=notec, name=VirBase, xleftmargin=4.5em]
	class D : public B, public C {
		D(int i, int j) : A(i), B(i), C(j){}
		/* 其他成员 */ };
\end{lstlisting}
\vspace{4.5\baselineskip}
\zhu[类的派生与类的组合]{；
	类的\tboqi{组合}，是指类申明时包含另一个类对象作为数据成员。
	
	类的组合和继承一样，都是有效地利用已有类的资源。但二者有着本质区别：继承是纵向（同一系族）的，组合是横向（不同系族）的。
}

\subsubsection{基类与派生类的兼容规则}

\tboba{基类与派生类的兼容规则}是指，在需要基类对象的地方，都可使用public派生类的对象来替代。也即，派生类对象可作为基类对象使用，但只能使用派生类中的「基类成员」。通过兼容规则，可以做到：\label{兼容规则}
\begin{itemize}
	\item 派生类对象向基类对象赋值；
	\item 派生类对象向基类对象的引用赋值，此时该引用与派生类对象的基类部分共享同一段存储单元；
	\item 基类对象的指针指向派生类对象。
\end{itemize}

\newpage
%----------------------------------------------
\section{消息}

\subsection{运算符重载}
C++中的运算符只能对基本类型的数据进行操作，作用比较有限。通过在运算符上重载新的操作意义，就可以用运算符操作自定义的对象。

\subsubsection{成员运算符函数}

在\textbf{类声明中}对运算符重载的一般格式为：
\begin{lstlisting}[style=intro]
	<-返回类型-> operator<-运算符-> (<-参数表->) { <-函数体-> }
\end{lstlisting}
也即，对运算符进行重载，可看做是将~\lstinline[style=intro]|operator<-运算符->|~这个函数重载给运算符。

\zhu[重载]{
	重载，是用户根据自己需要，对C++已有运算符或函数的功能重新赋予新的含义，使之“一词多义”的过程。函数和运算符都可以重载，但需要让程序明确何时使用哪一语义。为此，需要让各个重载的参数表（数目和类型）不同。
}

例如，现有类~\lstinline[moreemph={Complex}, emphstyle=\colors{qinglv}]|Complex|~中的复数相加函数~\lstinline[moreemph={Complex}, emphstyle=\colors{qinglv}]|Complex::add()|：
\begin{lstlisting}[moreemph={Complex}, emphstyle=\colors{qinglv}, moreemph={[2]{real, imag, c, cresult}}, emphstyle={[2]\it\ttfamily},]
	class Complex
	{
	private:
		double real, imag;
	public:
		Complex add(Complex& c)
		{
			Complex cresult;
			cresult.real = real + c.real;
			cresult.imag = imag + c.imag;
			return cresult;
		}
	};
\end{lstlisting}
将它作为函数原型，可以在类~\lstinline[moreemph={Complex}, emphstyle=\colors{qinglv}]|Complex|~中重载运算符「\texttt{+}」：
\begin{lstlisting}[moreemph={Complex}, emphstyle=\colors{qinglv}, moreemph={[2]{real, imag, c, cresult}}, emphstyle={[2]\it\ttfamily},]
	class Complex
	{
	private:
		double real, imag;
	public:
		Complex operator +(Complex& c)
		{
			Complex cresult;
			cresult.real = real + c.real;
			cresult.imag = imag + c.imag;
			return cresult;
		}
	};
\end{lstlisting}
此时，原先写成~\lstinline[moreemph={[2]{c1, c2, c3}}, emphstyle={[2]\it\ttfamily},]|c3 = c1.add(c2);|~的语句就可以写成~\lstinline[moreemph={[2]{c1, c2, c3}}, emphstyle={[2]\it\ttfamily},]|c3 = c1 + c2;|。

一般地，运算符重载的参数表有如下规定：
\begin{itemize}
	\item \textbf{双目运算符}的重载声明为一元的成员函数（如上例），运算符前面的对象（如上面的\texttt{\textit{c1}}）就是调用运算符函数的对象（即上面\texttt{.add}前面的对象），而运算符后面的对象（或运算符函数形参类型的数据变量）作为函数的实参；
	
	\item \textbf{前置单目运算符}的重载声明为零元的成员函数；若函数是对对象的成员进行操作，其返回值常为\texttt{*\textit{this}}，如：
	\begin{lstlisting}[xleftmargin=1em, moreemph={Complex}, emphstyle=\colors{qinglv}, moreemph={[2]{real, imag, this}}, emphstyle={[2]\it\ttfamily},]
	class Complex
	{
	private:
		double real, imag;
	public:
		Complex operator ++()
		{
			real += 1;
			return *this;
		}
	};			
	\end{lstlisting}
	\item \textbf{后置单目运算符}的重载声明为带有一个无名\texttt{int}参数的成员函数，如：
	\begin{lstlisting}[xleftmargin=1em, moreemph={Complex}, emphstyle=\colors{qinglv}, moreemph={[2]{real, imag, this, temp}}, emphstyle={[2]\it\ttfamily},]
	class Complex
	{
	private:
		double real, imag;
	public:
		Complex operator ++(int)
		{
			Complex temp(*this);
			real += 1;
			return temp;
		}
	};
	\end{lstlisting}
\end{itemize}

上面两个例子保持了前置、后置\texttt{++}的原有语义，即前置\texttt{++}返回值为自增后的值，后置\texttt{++}返回值为自增前的值。习惯上，运算符重载只是扩大原有运算符的适用范围，不改变运算符的原有语义。

\zhu[运算符重载的其他规则]{
	（1）重载不能改变运算符操作数的个数、优先级别、结合性；

	（2）重载运算符的函数不能有默认的参数；

	\hang[2]（3）重载运算符必须和用户定义的自定义类型的对象一起使用，其参数至少应有一个是类对象（或类对象的引用）；

	（4）用于类对象的运算符必须重载；但有两个例外，即运算符「\texttt{=}」和「\texttt{\&}」不必用户重载。
}

\subsubsection{友元运算符函数}

外部函数可以声明为类的\tboba{友元}，从而可以访问类的私有成员。友元函数的声明形式为在类的\texttt{public}限定符下写：
\begin{lstlisting}[style=intro]
	friend <-返回类型-> <-函数名-> (<-参数表->);
\end{lstlisting}
也即在函数声明前加关键字\texttt{friend}。

双目运算符要重载为第一操作数不为类对象的运算符函数，就必须重载为友元函数，如：
\begin{lstlisting}[moreemph={Complex}, emphstyle=\colors{qinglv}, moreemph={[2]{real, imag, c, cresult, r}}, emphstyle={[2]\it\ttfamily},]
	class Complex
	{
	private:
		double real, imag;
	public:
		friend Complex operator +(double r, Complex& c);
	};
	Complex operator +(double r, Complex& c)
	{
		Complex cresult;
		cresult.real = r + c.real;
		cresult.imag = c.imag;
		return cresult;
	}
\end{lstlisting}
其他运算符重载的函数也可以放到类外，然后在类中声明为友元函数；但这会破坏类的封装性，一般只会在重载的运算符第一操作数不为本类对象，或有操作数为其他类对象等必要情况下才使用。

\subsubsection{运算符重载的应用实例}\label{ssSec: 运算符重载的应用实例}

\paragraph{流的提取、插入运算符}\label{Par: 流的提取、插入运算符}

头文件\texttt{iostream}中，定义了输入流类\texttt{istream}和输出流类\texttt{ostream}；\texttt{cin}和\texttt{cout}分别是\texttt{istream}类和\texttt{ostream}类的对象，且是全局对象；流插入运算符「\texttt{<<}」和流提取运算符「\texttt{>>}」是位运算符「\texttt{<<}」「\texttt{>>}」在\texttt{istream}类和\texttt{ostream}类中的重载，用来输出和输入标准类型数据。

对自定义类型数据，要使得「\texttt{<<}」「\texttt{>>}」也可以用于输入输出，则需要再次重载，形式为：
\begin{lstlisting}[style=intro]
	istream & operator >> (istream &, <-自定义类名-> &);
	ostream & operator << (ostream &, <-自定义类名-> &);
\end{lstlisting}
下面是一个例子。
\begin{lstlisting}[moreemph={Complex, istream, ostream}, emphstyle=\colors{qinglv}, moreemph={[2]{real, imag, i, r, c, output, input, c1, c2}}, emphstyle={[2]\it\ttfamily},]
	#include <iostream>
	using namespace std;
	class Complex
	{
	private:
		double real, imag;
	public:
		Complex() { real = 0; imag = 0; }
		Complex(double r, double i) { real = r; imag = i; }
		friend ostream & operator << (ostream &, Complex &);		// 声明 << 重载为友元函数
		friend istream & operator >> (istream &, Complex &);		// 声明 >> 重载为友元函数
	};

	ostream & operator << (ostream & output, Complex & c)			// << 对 Complex 类的重载定义
	{
		output << "(" << c.real;
		if (c.imag >= 0) output << "+";								// 虚部非负时加上加号
		output << c.imag << "i)";
		return output;					// 保持 << 可以连续输出，即前面的「cout << c」返回 cout
	}
	istream & operator >> (istream & input, Complex & c)			// >> 对 Complex 类的重载定义
	{
		cout << "Input the real part and the imaginary part of a complex number: " << endl;
		input >> c.real >> c.imag;
		return input;					// 保持 >> 可以连续输入，即前面的「cin >> c」返回 cin
	}

	int main()
	{
		Complex c1, c2;
		cin >> c1 >> c2;
		cout << "c_1 = " << c1 << endl << "c_2 = " << c2 << endl;
		return 0;
	}
\end{lstlisting}

\paragraph{带有越界检测的下标运算符}

下标运算符「\texttt{[]}」是C++常用运算符，但\texttt{[]}没有定义下标越界的检测功能，而下标越界的错误很容易产生。因此，考虑通过运算符重载，对下标运算符增加一个越界检测功能。

例如，定义一个替代int类型数组的类：
\begin{lstlisting}[name=intVector, 
	moreemph={intVector}, emphstyle=\colors{qinglv}, moreemph={[2]{data, size, n}}, emphstyle={[2]\it\ttfamily},
	morekeywords={delete[]}
]
	class intVector
	{
		int* data;
		int size;
	public:
		intVector() { data = NULL; size = 0; }
		~intVector() { if (data != NULL) delete[] data; }
		int & operator [](int n);
	};
\end{lstlisting}
其下标运算符\texttt{[]}重载为 
\begin{lstlisting}[name=intVector, 
	moreemph={intVector}, emphstyle=\colors{qinglv}, moreemph={[2]{data, size, n}}, emphstyle={[2]\it\ttfamily},
	morekeywords={delete[]}
]
	int & intVector::operator [](int n)
	{
		assert(n >= 0 && n < size);
		return data[n];
	}
\end{lstlisting}
其中，\lstinline{operator []}~返回值为int的引用，以使得其结果可以为左值。\textbf{assert()断言函数}是头文件\texttt{assert.h}中的一个调试用函数，当其实参表达式的结果为0时断言失败、程序出错，会向标准输出设备打印一条错误信息，并调用abort()终止程序。

\zhu[assert()的使用]{
	assert()断言失败抛出的error信息格式为：
	\vspace{2.5\baselineskip}

	通过抛出的error信息，可以知道出错的表达式及其位置，因而assert()常用于在函数开始处检验传入参数的合法性，即做合法性判断，防止后面表达式出错。因而，最好每个assert()只检验一个条件，因为同时检验多个条件时，如果断言失败，无法直观的判断是哪个条件失败。

	代码编辑中解决方案配置有Debug和Release两种模式，Debug是程序员在测试代码期间使用的编译模式，Release是软件交付的编译模式。在Release模式下不应该调用assert()，否则会抛出一段看不到的提示信息，并毫无预警地终止程序。assert.h中对此有一定准备：
	\vspace{11.7\baselineskip}

	当没有宏定义\texttt{NDEBUG}时才会抛出错误信息，而有宏定义\texttt{NDEBUG}时，\texttt{assert(expression)}即不会执行。因此，在assert()中不能使用改变环境的语句，否则一旦有宏定义\texttt{NDEBUG}就会使程序运行遇到问题。
}

\vspace{-23.2\baselineskip}
\begin{lstlisting}[style=output, xleftmargin=3.5em, xrightmargin=2.5em]
	Assertion failed: <-expression->, file <-_FILE_->, line <-_LINE_->
\end{lstlisting}
\vspace{5.7\baselineskip}
\begin{lstlisting}[style=notec, morekeywords={\#define}]
	#ifdef NDEBUG
    	#define assert(expression) ((void)0)
	#else
		_ACRTIMP void __cdecl _wassert(
			_In_z_ wchar_t const* _Message,
			_In_z_ wchar_t const* _File,
			_In_   unsigned       _Line
			);
		#define assert(expression) (void)(                                                       \
            (!!(expression)) ||                                                              \
            (_wassert(_CRT_WIDE(#expression), _CRT_WIDE(__FILE__), (unsigned)(__LINE__)), 0) \
        )
	#endif
\end{lstlisting}
\vspace{3\baselineskip}

类似地，也可以将二维数组下标（用「\texttt{()}」括起，用逗号分隔）运算符重载：
\begin{lstlisting}[
	moreemph={intMatrix}, emphstyle=\colors{qinglv}, moreemph={[2]{data, row, col, r, c}}, emphstyle={[2]\it\ttfamily},
	morekeywords={delete[]}
]
	class intMatrix
	{
		int* data;
		int row, col;
	public:
		intMatrix() { data = NULL; row = 0; col = 0; }
		~intMatrix() { if (data != NULL) delete[] data; }
		int & operator ()(int r, int c);
	};
	int & intMatrix::operator ()(int r, int c)
	{
		assert(r >= 0 && r < row && c >= 0 && c < col);
		return data[col * r + c];
	}
\end{lstlisting}

\paragraph{内存管理运算符}

new、delete运算符也可进行重载，其重载形式既可是类成员函数，也可是友元函数，但第1个参数类型必须是\texttt{size\_t}。如果类中没有定义 new 和 delete 的重载函数，那么会自动调用缺省 new 和 delete。

new先调用operator new申请内存，再调用构造函数初始化内存；delete先调用析构函数，再调用operatordelete释放内存。new[]与delete[]都只会调用一次operator new[]、operator delete[]，且是从前往后构造、从后往前析构。

\subsection{数据类型转换}

\subsubsection{转换构造函数}

\tboba{转换构造函数}以其他类型数据为参数，构建自身类的对象。转换构造函数只有一个参数，其格式与有参构造函数一致；事实上，\textbf{只有一个参数的构造函数均可视为转换构造函数}。转换构造函数会在形参与实参类型不相同时自动尝试调用，如
\label{sec. 转换构造函数} 
\begin{lstlisting}[moreemph={Complex, ostream}, emphstyle=\colors{qinglv}, moreemph={[2]{output, real, imag, c, r, i, c1, c2, c3, c4, c5}}, emphstyle={[2]\it\ttfamily},]
	#include <iostream>
	using namespace std;

	class Complex
	{
	private:
		double real, imag;
	public:
		Complex() { real = 0; imag = 0; }
			// 无参构造函数
		Complex(double r) { real = r; imag = 0; }
			// 构造函数的重载，同时是 double 到 Complex 的转换构造函数
		Complex(double r, double i) { real = r; imag = i; }
			// 构造函数的重载
		friend Complex operator +(Complex c1, Complex c2);
			// 以 Complex 类对象为参的运算符函数
		friend ostream& operator <<(ostream& output, Complex c);
			// Complex 类对象输出函数
	};
	Complex operator +(Complex c1, Complex c2)
	{
		return Complex(c1.real + c2.real, c1.imag + c2.imag);
	}
	ostream& operator <<(ostream& output, Complex c)
	{
		output << "(" << c.real << ", " << c.imag << ")";
		return output;
	}
			
	int main()
	{
		Complex c1(3, 4), c2(5), c3, c4, c5; int i = 2;
								// c2 的构造调用构造函数第 2 个重载
		c3 = c1 + 2.5;			// 运算符重载调用转换构造函数，相当于 c3 = c1 + Complex(2.5)
		c4 = 2.5 + c2;			// 运算符重载调用转换构造函数，相当于 c4 = Complex(2.5) + c2
		c5 = 2.5 + i;			// 赋值语句调用转换构造函数，相当于 c5 = Complex(2.5 + i)
		cout << c1 << " " << c2 << " " << c3 << " " << c4 << " " << c5 << " " << endl;
		return 0;
	}
\end{lstlisting}
其输出为
\begin{lstlisting}[style=output]
	(3, 4) (5, 0) (5.5, 4) (7.5, 0) (4.5, 0)
\end{lstlisting}

\subsubsection{类型转换运算符}

标准类型的类型名可以用于将其他标准类型数据强制转换为该类型数据，此为C中的强制转换运算符。沿用这一思路，类型名也可以用作将某类对象转换为该类型的运算符。类型转换运算符函数的重载形式为：
\label{sec. 类型转换运算符} 
\begin{lstlisting}[style=intro]
	operator <-类型名-> () { /* 实现转换的语句 */ }
\end{lstlisting}
例如：
\begin{lstlisting}[moreemph={Complex, ostream}, emphstyle=\colors{qinglv}, moreemph={[2]{output, real, imag, c, r, i, c1, c2, c3, c4, c5}}, emphstyle={[2]\it\ttfamily},]
	#include <iostream>
	#include <cmath>				// hypot() 函数所需
	using namespace std;
	
	class Complex
	{
	private:
		double real, imag;
	public:
		Complex() { real = 0; imag = 0; }
			// 无参构造函数
		Complex(double r, double i) { real = r; imag = i; }
			// 构造函数的重载
		operator double() { return hypot(real, imag); }
			// Complex 向 double 的类型转换运算符，取复数的模
	};
	
	int main()
	{
		Complex c(3, 4);
		double d = 2.5 + c;			// 调用类型转换函数，类似于 d = 2.5 + double(c1)
		cout << d << endl;
		return 0;
	}
\end{lstlisting}

\subsubsection{类型转换冲突}

当类的运算符重载、转换构造函数、类型转换运算符重载的定义不使得语句有二义性时，程序能够正常运行。例如上面的例子中
\begin{itemize}
	\item \ref{sec. 转换构造函数}~节转换构造函数的例子中\texttt{double $\to$ Complex}转换构造函数、\texttt{double + double}标准类型运算和\texttt{Complex + Complex}运算符重载同时存在，\texttt{Complex}与\texttt{double}的加法表达式没有二义性；
	\item \ref{sec. 类型转换运算符}~节类型转换运算符的例子中只存在\texttt{Complex $\to$ double}类型转换运算符和\texttt{double + double}标准类型运算，\texttt{Complex}与\texttt{double}的加法表达式也没有二义性，即使存在\texttt{double $\to$ Complex}转换构造函数也没有；
	\item 容易类推，若同时存在\texttt{Complex $\to$ double}类型转换运算符、\texttt{double + double}标准类型运算和\texttt{Complex + Complex}运算符重载，\texttt{Complex}与\texttt{double}的加法表达式也没有二义性。
\end{itemize}
但是，若同时定义了\texttt{double $\to$ Complex}转换构造函数、\texttt{Complex $\to$ double}类型转换运算符、\texttt{double + double}标准类型运算和\texttt{Complex + Complex}运算符重载，那\texttt{Complex}与\texttt{double}的加法表达式就有二义性，程序编译不通过，编译器报错：
\begin{lstlisting}[language={}, numbers=none]
	错误(活动)	E0350	有多个运算符 "+" 与这些操作数匹配:
						内置运算符 "arithmetic + arithmetic"
       	    			函数 "operator+(Complex c1, Complex c2)" (已声明 所在行数:16)
        					操作数类型为:  double + Complex
\end{lstlisting}

类型转换函数可以简化代码编写，利用隐式自动类型转换可以将原本多个运算符函数合并成一个，但过多地使用隐式的自动类型转换会给程序带来隐患。编写程序时应当尽量使用显式类型转换，少用隐式类型转换。

\subsection{多态性与虚函数}

\subsubsection{虚函数与动态绑定}

\tboba{虚函数}是为解决多层继承的同名函数统一调用问题而引入的。在基类与派生类中，如果有同名函数，我们只能通过类名限定符（如写明\texttt{deobj.Base::func()}与\texttt{deobj.func()}）来唯一标识，以调用不同派生层次中的同名函数。若不这样，通过对象访问时将应用同名覆盖规则（\ref{同名覆盖规则}~节）访问对象所属类的该同名函数，但不便于用数组、指针统一管理；通过基类的指针或引用访问时将应用兼容规则（\ref{兼容规则}~节），只能访问基类中的该同名函数。
例如，给出如下的类：
\begin{lstlisting}[moreemph={Point, Circle, Cylinder}, emphstyle=\colors{qinglv}, moreemph={[2]{x, y, a, b, os, p, radius, r, c, height, h}}, emphstyle={[2]\it\ttfamily},]
	class Point // Base class : Point
	{
	protected:
		double x, y;
	public:
		Point(double a = 0, double b = 0) : x(a), y(b) {}
		void setPoint(double a, double b) { x = a; y = b; }
		double getX() const { return x; }
		double getY() const { return y; }
		friend ostream& operator<<(ostream& os, const Point& p);
	};
	
	class Circle : public Point // Derived class : Circle, inherits from Point
	{
	protected:
		double radius;
	public:
		Circle(double a = 0, double b = 0, double r = 0) : Point(a, b), radius(r) {}
		void setRadius(double r) { radius = r; }
		double getRadius() const { return radius; }
		double getArea() const { return 3.1415926 * radius * radius; }
		void printArea() const { cout << "Area of the circle is: " << getArea() << endl; }
		friend ostream& operator<<(ostream& os, const Circle& c);
	};
		
	class Cylinder : public Circle  // Derived class : Cylinder, inherits from Circle
	{
	protected:
		double height;
	public:
		Cylinder(double a = 0, double b = 0, double r = 0, double h = 0) : Circle(a, b, r), height(h) {}
		void setHeight(double h) { height = h; }
		double getHeight() const { return height; }
		double getVolume() const { return 3.1415926 * radius * radius * height; }
		void printVolume() const { cout << "Volume of the cylinder is: " << getVolume() << endl; }
		void printArea() const { cout << "Area of the cylinder is: " << 2 * getArea() + 2 * 3.1415926 * radius * height << endl; }
		friend ostream& operator<<(ostream& os, const Cylinder& c);
	};
\end{lstlisting}
则下面的主函数
\begin{lstlisting}[firstnumber=40, moreemph={Point, Circle, Cylinder}, emphstyle=\colors{qinglv}, moreemph={[2]{x, y, a, b, os, p, radius, r, c, height, h, arrMix, i}}, emphstyle={[2]\it\ttfamily}]
	int main()
	{
		Circle* arrMix[5];
		for (int i = 0; i < 3; i++)
			arrMix[i] = new Cylinder(0, 0, i, i);
		for (int i = 3; i < 5; i++)
			arrMix[i] = new Circle(0, 0, i);
		for (int i = 0; i < 5; i++)
			arrMix[i]->printArea();
		return 0;
	}
\end{lstlisting}
将输出
\begin{lstlisting}[style=output]
	Area of the circle is: 0
	Area of the circle is: 3.14159
	Area of the circle is: 12.5664
	Area of the circle is: 28.2743
	Area of the circle is: 50.2655
\end{lstlisting}
也即，由于指针数组定义为基类的指针，根据兼容规则只会调用基类的\texttt{printArea()}方法。但为了统一管理，不同类的对象又需要在同一数组之中，这就造成了不便。

而，引入虚函数后，用同一语句「\texttt{\textit{pobj}->func();}」，既能调用派生类的同名函数，也能调用基类的同名函数。在调用前给指针变量\texttt{\textit{pobj}}赋以不同类对象，即可调用不同派生层次中的\texttt{func()}函数，从而实现动态多态性。虚函数定义的一般格式为：
\begin{lstlisting}[style=intro]
	virtual <-虚函数的返回类型-> <-函数名-> { <-函数体-> }
\end{lstlisting}
在上面的例子中，即将第22行和第36前分别加\texttt{virtual}。此时，同样的主函数的输出就变为
\begin{lstlisting}[style=output]
	Area of the cylinder is: 0
	Area of the cylinder is: 12.5664
	Area of the cylinder is: 50.2655
	Area of the circle is: 28.2743
	Area of the circle is: 50.2655
\end{lstlisting}

总的来说，虚函数的作用就是允许在派生类中重新定义与基类同名的函数，且可以\textbf{通过基类指针或引用来访问}基类和派生类中的同名函数。同一类族中不同类的对象，对同一虚函数的调用将作出不同的响应。

\zhu[虚函数的声明注意]{
	\hang[2]（1）在基类中，用\texttt{virtual}声明成员函数为虚函数，这样就可以在派
	生类中重新定义此函数，为它赋予新的功能；

	\hang[2]（2）在派生类中重新定义此函数时，要求函数名、函数类型、函数参数个数和类型全部与基类的虚函数相同，只能根据派生类的需要重新定义函数体；

	\hang[2]（3）在类外定义虚函数时，不必再加\texttt{virtual}；基类已声明的虚函数在派生类中的同名函数都自动成为虚函数，因此在派生类重新声明该虚函数时，\texttt{virtual}可加可不加，但建议仍加上以提高可读性。
}

函数名确定调用的具体对象的过程称为\tboba{关联}或\tboba{绑定}，其即是把一个函数名与一个类对象捆绑在一起的过程。函数重载和通过对象名调用的虚函数，在编译时即可确定其调用的函数属于哪一个类，因此称为\tboba{静态关联}或\tboba{编译时关联}；对应地，通过基类指针或引用调用的虚函数在编译时并不知道指针或引用的内容对应于哪一个函数体，必须要到运行时才能确定具体调用的函数版本，所以这种函数行为的绑定称为\tboba{动态绑定}，又叫\tboba{运行时绑定}。

\zhu[虚函数与重载函数的区别]{
	（1）重载函数函数名称相同，参数不同；重载函数，是在作用域相同的区域里定义的相同名字的不同函数；虚函数函数原型完全一致，体现在基类和派生类的类层次结构中；

	（2）重载函数可以是成员函数或友员函数或一般函数，而虚函数只能是成员函数；

	\hang[2]（3）调用重载函数以所传递参数序列的差别作为调用不同函数的依据，虚函数则根据对象的不同来调用不同类的虚函数；

	\hang[2]（4）重载函数在编译时表现出多态性，是静态联编（早期绑定）；而虚函数在运行时表现出多态性，是动态联编（晚期绑定），动态联编是C++的精髓。
}

一类特殊的情况是，当用基类指针指向派生类对象时，对指针使用delete运算符撤销对象，调用的是基类的析构函数。因此，如果有用基类指针统一管理派生类对象的需求，\textbf{最好将基类析构函数声明为虚函数}。

\subsubsection{纯虚函数与抽象类}

基类中定义虚函数可能不是基类本身需求，而是派生类的需要。如上面例子中，基类 \texttt{Point} 中没有面积，但在其派生类 \texttt{Circle} 和 \texttt{Cylinder} 中都需要\texttt{printArea()}函数。结构性更强的做法是在最原始的基类 \texttt{Point} 中声明一个没有函数体、只有函数名的虚函数（而非向上例中在中间派生类 \texttt{Circle} 中声明虚函数），这个虚函数称为\tboba{纯虚函数}。纯虚函数声明的一般格式为：
\begin{lstlisting}[style=intro]
	virtual <-函数类型-> <-函数名-> (<-参数表列->) = 0;
\end{lstlisting}

纯虚函数只有函数名而不具备函数功能，不能被调用。其作用是在基类中为其派生类保留一个函数名，以便派生类根据需要对它进行定义。声明一个纯虚函数的唯一目的就是\textbf{在后续派生中实现多态性}。

因为纯虚函数不能被调用，包含纯虚函数的类无法建立对象，因而称为\tboba{抽象类}（abstract class）。声明一个抽象类并不是用来定义对象，而只是作为基类去建立派生类。用户在抽象类的基础上根据需要赋予纯虚函数功能，定义出功能各异的派生类，再用这些派生类去建立对象。

\zhu[抽象类的使用]{
	面向对象的程序设计，其层次结构的顶部是抽象类，甚至有几层都是抽象类。如果在抽象类所派生出的新类中对所有纯虚函数进行了定义，被赋予了功能。则该派生类就成为可定义对象的\tboqi{具体类}（concrete class），否则仍为抽象类。
	
	抽象类不能定义对象，但\tboqi{可定义指向抽象类数据的指针变量}。当派生类成为具体类后，就可以用该指针指向派生类对象，然后通过指针调用虚函数，实现多态性。
	
	抽象类不能作为参数、函数或显式转换等类型。
}

\subsubsection{多态性}

我们希望实现，程序向不同对象发送同一个消息（调用同名函数），不同对象在接收时会产生不同行为、实现不同功能，以此提高代码的利用效率。这种特性称为程序的\tboba{多态性}。多态能对不同对象使用同样的接口，既提高程序维护的可靠性，又使得不同对象的内部设计与外部使用接口分离，类的设计者与类的使用者可以分工协作。

多态性按照其主体可以分为
\begin{itemize}
	\item \textbf{重载多态}：函数或运算符重载，依据参数的不同实现；
	\item \textbf{强制多态}：数据或对象的类型强制转换；
	\item \textbf{包含多态}：研究类族中定义同名成员函数的多态行为，主要通过虚函数来实现；
	\item \textbf{参数多态}：类模板实例化时的多态性，即实例化后的各个类都具有相同的操作。
\end{itemize}
按照其实现可以分为
\begin{itemize}
	\item \textbf{静态多态性}：编译时多态性，例如函数重载、运算符重载、强制类型转换等；
	\item \textbf{动态多态性}：运行时多态性，程序运行过程中动态确定操作所针对的对象，主要通过虚函数实现。
\end{itemize}

抽象基类体现了本类族中各类的共性，把本类族中共有的成员函数集中在抽象基类中声明（尽管对其功能完全没有设计），作为本类族的公共接口。从抽象基类派生出的多个类具有共同的接口。多态的真正威力在于，程序员可以事先设计一些使用其它模块的代码，对模块的实现细节却可以一无所知。这样，一个模块的修改乃至于功能的添加都不会影响到其它模块的代码。

\newpage
%----------------------------------------------
\section{工具}

\subsection{输入输出流}

\tboba{流}是从一个对象到另一个对象的数据流动的字节序列。内存中为每个流开辟了一个内存缓冲区，用来存放流中的数据，即流与内存缓冲区相对应。

\subsubsection{C++的I/O流结构}

C++的输入、输出（I/O）分为这样三种类型：
\begin{itemize}
	\item \textbf{标准I/O\quad}对系统指定的标准设备进行输入输出操作；
	\item \textbf{文件I/O\quad}以磁盘文件为对象进行输入输出操作，即从磁盘文件输入、输出数据到磁盘文件；
	\item \textbf{字串I/O\quad}对内存中指定空间（通常为一个字符数组）进行输入和输出。
\end{itemize}
相应地，就有三种\tboba{输入输出流}：
\begin{itemize}
	\item \textbf{标准流\quad}用于程序与输入输出设备之间的数据交互；
	\item \textbf{文件流\quad}用于程序与磁盘文件之间的数据交互；
	\item \textbf{字串流\quad}用于程序与内存字符数组之间的数据交互。
\end{itemize}
C++编译系统会对数据类型进行严格检查，凡是类型不正确数据都不能通过编译，确保\textbf{类型安全}；C++的输入输出命令不仅可以用来输入、输出标准类型的数据，也可输入输出用户自定义类型的数据，即具有\textbf{可扩展性}。

C++的I/O流被定义为不同的\tboba{流类}（stream class）。\texttt{ios}是抽象基类，派生出\texttt{istream}类支持I操作、\texttt{ostream}类支持O操作，这两个派生类派生出\texttt{iostream}类支持I/O操作。\texttt{istream}、\texttt{ostream}类分别派生出\texttt{ifstream}和\texttt{ofstream}类支持文件操作，\texttt{ifstream}支持对文件的I操作，\texttt{ofstream}支持对文件的O操作。用流类定义的对象称为\tboba{流对象}，\texttt{cout}和\texttt{cin}是iostream类的全局对象。

\subsubsection{标准I/O流操作}

标准I/O流实现程序中对象与标准I/O设备（对象）之间的数据交换。
进行标准输出操作时，程序对象数据先预存在缓存区中，直到满或者遇到\texttt{endl}，缓冲区的全部数据自动送到屏幕或磁盘文件；输入时，键盘键入的数据先预存到缓冲区，当按回车键，才读入到程序中的对象。

\paragraph{\texttt{>>}与\texttt{<<}运算符}

\texttt{istream}、\texttt{ostream}类分别以\textbf{成员函数}的形式重载了运算符\texttt{>>}、\texttt{<<}作为标准类型的流提取、插入运算符，其格式均为
\begin{lstlisting}[style=intro]
	istream & operator >> (<-标准类型->);
	ostream & operator << (<-标准类型->);
\end{lstlisting}
而对于自定义类型数据（自定义类的变量），则需要重载这两个运算符为自定义类的\textbf{友元函数}，即如~\ref{ssSec: 运算符重载的应用实例}~节~\ref{Par: 流的提取、插入运算符}~所述，形式为：
\begin{lstlisting}[style=intro]
	istream & operator >> (istream &, <-自定义类名-> &);
	ostream & operator << (ostream &, <-自定义类名-> &);
\end{lstlisting}


\paragraph{输出格式控制}

\texttt{cout <<}输出数据时，系统会判断数据类型，根据其类型选择调用与之匹配的运算符重载函数，将数据插入到对应的内存缓冲区中；当向cout流插入一个\texttt{endl}时，终止一行字符串并刷新缓冲区；插入\texttt{ends}时，终止字符串并插入空格符。

cout流的输出格式可有下面两种方式控制：
\begin{itemize}
	\item \textbf{使用控制符控制输出格式}：头文件\texttt{<iomanip>}中定义了输出流控制符如表~\ref{Tab: 输入输出流的控制符}~所示。
	\begin{table}[ht!]
		\caption{输入输出流的控制符}\label{Tab: 输入输出流的控制符}
		\centering
		\begin{tabular}{lll}
			\toprule
			\textbf{控制符} & \multicolumn{2}{l}{\textbf{该控制符的作用}}\\
			\midrule
			\texttt{dec} & 基数 & 使用十进制 \\
			\texttt{hex} & ~ & 使用十六进制 \\
			\texttt{oct} & ~ & 使用八进制 \\
			\texttt{setbase(\textit{n})} & ~ & 设置整数的基数为\texttt{\textit{n}}（可取值为\texttt{8 | 10 | 16}） \\
			\texttt{setfill(\textit{c})} & 对齐 & 设置「填充字符」为\texttt{\textit{c}} \\
			\texttt{setw(\textit{n})} & ~ & 固定下一输出项宽度为\texttt{\textit{n}}位字符，不足用「填充字符」填充 \\
			\texttt{setprecision(\textit{n})} & 小数表示 & 设置实数的精度为\texttt{\textit{n}}位：\\
			~ & ~ & \quad\makecell[l]{以一般十进制小数形式输出时，\texttt{\textit{n}}代表有效数字；\\以固定小数位数（\texttt{fixed}）形式或科学计数（\texttt{scientific}）\\形式输出时，\texttt{\textit{n}}代表小数位数} \\
			\texttt{setiosflags(ios::\textit{FLAG})} & 设置格式 & 启用\texttt{\textit{FLAG}}格式状态，可选的\texttt{\textit{FLAG}}见表~\ref{Tab: 格式状态标志} \\
			\texttt{resetiosflags(ios::\textit{FLAG})} & 清除格式 & 终止已设置的\texttt{\textit{FLAG}}格式状态 \\
			\bottomrule
		\end{tabular}
	\end{table}
	\begin{table}[ht!]
		\caption{可选的\texttt{\textit{FLAG}}格式状态标志}\label{Tab: 格式状态标志}
		\centering
		\begin{tabular}{lll}
			\toprule
			\textbf{\texttt{\textit{FLAG}}} & \multicolumn{2}{l}{\textbf{格式状态的含义}}\\
			\midrule
			\texttt{dec} & 基数 & 使用十进制 \\
			\texttt{hex} & ~ & 使用十六进制 \\
			\texttt{oct} & ~ & 使用八进制 \\
			\texttt{left} & 对齐 & 左对齐 \\
			\texttt{right} & ~ & 右对齐 \\
			\texttt{internal} & ~ & 符号位左对齐，数值右对齐，中间由「填充字符」填充 \\
			\texttt{showbase} & 记号 & 强制输出基数标志\texttt{0}和\texttt{0x} \\
			\texttt{showpoint} & ~ & 强制输出浮点数的小数点和尾数0 \\
			\texttt{uppercase} & ~ & 科学计数形式标志\texttt{e}和十六进制形式标志\texttt{x}换为大写 \\
			\texttt{showpos} & ~ & 输出正数时输出「\texttt{+}」号 \\
			\texttt{fixed} & 小数形式 & 设置浮点数以固定小数位数形式表示 \\
			\texttt{scientific} & ~ & 设置浮点数以科学计数形式表示 \\
			\texttt{skiows} & 流控制 & 忽略前导空格 \\
			\texttt{unitbuf} & ~ & 每次输出之后刷新所有流 \\
			\texttt{stdio} & ~ & 每次输出之后刷新stdout流和stderr流 \\
			\bottomrule
		\end{tabular}
	\end{table}
	\item \textbf{使用流对象的成员函数控制输出格式}：
	控制输出格式的流对象成员函数定义在流类中，与对应的控制符有相同的作用，如表~\ref{Tab: 控制输出格式的流对象成员函数}~所示。
	\begin{table}[ht!]
		\caption{控制输出格式的流对象成员函数}\label{Tab: 控制输出格式的流对象成员函数}
		\centering
		\begin{tabular}{llll}
			\toprule
			\textbf{流成员函数} & \textbf{对应的控制符} & \multicolumn{2}{l}{\textbf{该函数的作用}}\\
			\midrule
			\texttt{fill(\textit{c})} & \texttt{setfill(\textit{c})} & 对齐 & 设置「填充字符」为\texttt{\textit{c}} \\
			\texttt{width(\textit{n})} & \texttt{setw(\textit{n})} & ~ & 固定下一输出项宽度为\texttt{\textit{n}}位字符，不足用 \\
			~ & ~ & ~ & \quad「填充字符」填充 \\
			\texttt{precision(\textit{n})} & \texttt{setprecision(\textit{n})} & 小数表示 & 设置实数的精度为\texttt{\textit{n}}位：\\
			~ & ~ & ~ & \quad\makecell[l]{以一般十进制小数形式输出时，\texttt{\textit{n}}代表\\有效数字；\\以固定小数位数（\texttt{fixed}）形式或科学计\\数（\texttt{scientific}）形式输出时，\texttt{\textit{n}}代表\\小数位数} \\
			\texttt{setf(ios::\textit{FLAG})} & \texttt{setiosflags(ios::\textit{FLAG})} & 设置格式 & 启用\texttt{\textit{FLAG}}格式状态，\texttt{\textit{FLAG}}见表~\ref{Tab: 格式状态标志} \\
			\texttt{unsetf(ios::\textit{FLAG})} & \texttt{resetiosflags(ios::\textit{FLAG})} & 清除格式 & 终止已设置的\texttt{\textit{FLAG}}格式状态 \\
			\bottomrule
		\end{tabular}
	\end{table}
\end{itemize}

\paragraph{标准错误流} 

调试程序时，往往不希望程序运行时的出错信息被送到文件，而要求在显示器上及时输出，为此\texttt{ostream}类中还构建了2个流对象\texttt{cerr}和\texttt{clog}，称为\tboba{标准错误流对象}，其作用是向标准错误设备输出有关出错信息，被指定与显示器关联。\texttt{cerr}、\texttt{clog}流中的信息是用户根据需要指定的。

这两个流的区别在于，cerr流不经过缓冲区，直接向显示器上输出有关信息，而clog流中的信息存放在缓冲区中，缓冲区满后或遇\texttt{endl}时才向显示器输出。

\paragraph{标准输入输出函数}

标准输入、输出类的对象，还可以使用以下这些类成员函数进行输入输出。

\begin{description}[leftmargin=2em, labelsep=1em, itemindent=-1em, itemsep=0pt, parsep=0pt, topsep=3pt, partopsep=0pt]
	\item[\texttt{put()}] 
	\texttt{ostream}类提供的专用于\textbf{输出单个字符}的成员函数，使用如
\begin{lstlisting}[xleftmargin=1em]
	cout.put('a');
\end{lstlisting}
	即输出字符{\mono a}。\texttt{put()}函数的参数可是字符或字符的ASCII代码，也可是一个整型表达式。

	\item[\texttt{get()}]
	\texttt{istream}类提供的成员函数，其有三个重载，即三种调用形式：
	\begin{itemize}[leftmargin=1em, topsep=0pt]
		\item 无参数调用，如
\begin{lstlisting}[xleftmargin=1em, moreemph={[2]{ch}}, emphstyle={[2]\it\ttfamily}]
	char ch = cin.get();
\end{lstlisting}
		从输入流中读取一个字符，返回值是读入字符。若遇到输入流中的文件结束符，则返回文件结束标志\texttt{E0F}。
		\item 单参数调用，如
\begin{lstlisting}[xleftmargin=1em, moreemph={[2]{ch}}, emphstyle={[2]\it\ttfamily}]
	cin.get(ch);
\end{lstlisting}
		从输入流中读取一个字符，赋给其参数字符变量\texttt{\textit{ch}}。如果读取成功则函数返回非0值，如失败（遇文件结束符）则函数返回0。
		\item 三参数调用，其调用形式为
\begin{lstlisting}[xleftmargin=1em, style=intro]
	cin.get(<-字符数组或指针->, <-字符个数->, <-终止符->);
\end{lstlisting}
		从输入流中读取\,\lstinline[style=intro]|<-字符个数->|\,$\mathop-1$个字符，如果在读取\,\lstinline[style=intro]|<-字符个数->|\,$\mathop-1$个字符之前遇到指定的终止字符，则提前结束读取。如果读取成功则函数返回非0值，如失败（遇文件结束符）则函数返回0值。
	\end{itemize}

	\item[\texttt{getline()}]
	\texttt{istream}类还提供了成员函数\texttt{getline()}，其调用形式及作用与上面\texttt{get()}的三参数形式相同。

	\zhu[\texttt{getline(char *, int, char)}和\texttt{get(char *, int, char)}的区别]{
		\texttt{cin.getline()}和\texttt{cin.get()}的功能基本相同，其区别在于因遇到终止符停止读取时，\texttt{cin.get()}虽不会将终止符保存在数组中，但\tboqi{仍然保留在输入流中}，因此除非使用\texttt{cin.ignore()}等将终止符从输入流中删除，否则紧接着的第2个\texttt{cin.get()}操作结果为空；而\texttt{cin.getline()}要\tboqi{从输入流中删除终止符}（即读取它并删除），也不将它保存在数组中。
	}

	\texttt{getline()}在读入\,\lstinline[style=intro]|<-字符个数->|\,$\mathop-1$字符后会清除缓存，但遇到结束符提前结束不清空。

	\item[\texttt{eof()}]
	从输入流读取数据，若到达文件末或\texttt{\^Z}（Ctrl+Z），返回非零值，否则返回0。

	\item[\texttt{peek()}]
	返回指针指向的当前字符，指针仍停留在当前位置，并不后移。如果要访问的字符是结束符，则返回\texttt{E0F}（值为$-1$的全局宏）。
	\item[\texttt{ignore()}] 
	定义为
\begin{lstlisting}[xleftmargin=1em, 
	moreemph={istream}, emphstyle=\colors{qinglv}, 
	moreemph={[2]{_Count, _Metadelim}}, emphstyle={[2]\it\ttfamily},]
	istream & ignore(std::streamsize _Count = 1i64, int _Metadelim = EOF)
\end{lstlisting}
	逐个跳过输入流中的若干字符，直至刚刚跳过指定的\,\lstinline[style=intro]|<-终止符->|\,\texttt{\textit{\_Metadelim}}或跳过的字符数达到\,\lstinline[style=intro]|<-字符个数->|\,\texttt{\textit{\_Count}}。
\end{description}

\subsubsection{文件I/O流操作}

\tboba{文件}指存储在外部介质上数据集合，是\textbf{外存的数据管理单位}。文件流是以文件作为I/O对象的数据流。每一个文件流都有一个内存缓冲区与之对应。C++定义了3种用于文件I/O操作的\tboba{文件类}：
\begin{itemize}[topsep=0pt]
	\item \texttt{ifstream}类：\texttt{istream}类的派生类，支持文件输入；
	\item \texttt{ofstream}类，\texttt{ostream}类的派生类，支持文件输出；
	\item \texttt{fstream}类，\texttt{iostream}类的派生类，支持文件输入输出。
\end{itemize}

\paragraph{文件的打开与关闭}

文件的\tboba{打开}是指为\textbf{文件流对象}和指定的文件建立关联，以便使文件流流向指定的磁盘文件，并指定文件工作方式的操作。打开文件的方式有以下2种：
\begin{itemize}
	\item 调用\textbf{文件流对象的成员函数\texttt{open()}}，其一般形式为：
\begin{lstlisting}[style=intro, xleftmargin=1em]
	<-文件流对象->.open(<-文件名->, <-输入输出方式->);
\end{lstlisting}
	例如：
\begin{lstlisting}[xleftmargin=1em, 
	moreemph={ofstream}, emphstyle=\colors{qinglv}, 
	moreemph={[2]{outfile}}, emphstyle={[2]\it\ttfamily},]
	ofstream outfile;
	outfile.open("f1.dat", ios::out);
\end{lstlisting}
	\item 文件流类在声明时，定义了带参数的构造函数，其中包含了打开磁盘文件的功能。因此在定义文件流对象时\textbf{调用构造函数的这一重载}来实现「三个功能」，例如：
\begin{lstlisting}[xleftmargin=1em, 
	moreemph={ofstream}, emphstyle=\colors{qinglv}, 
	moreemph={[2]{outfile}}, emphstyle={[2]\it\ttfamily},]
	ofstream outfile("f1.dat", ios::out)
\end{lstlisting}
\end{itemize}

其中，「输入输出方式」可取值见表~\ref{Tab: 输入输出方式}，且可用「位或」运算符「\texttt{|}」进行组合，如\texttt{\textit{outfile}.open("f2.dat", ios::app | ios::nocreate);}。
\begin{table}[ht!]
	\caption{可选的文件输入输出方式}\label{Tab: 输入输出方式}
	\centering
	\begin{tabular}{lll}
		\toprule
		\textbf{输入输出方式标记} & \multicolumn{2}{l}{\textbf{输入输出方式说明}}\\
		\midrule
		\texttt{ios::in} & 工作方向 & 以输入方式打开 \\
		\texttt{ios::out} & ~ & 以输出方式打开；如有同名文件，则将原有内容全部清除 \\
		~ & ~ & {\kai（默认缺省值）} \\
		\texttt{ios::app} & ~ & 以输出方式打开；如有同名文件，则新写入的数据添加在文件末尾 \\
		\texttt{ios::ate} & ~ & 打开一个已有的文件；文件指针指向文件末尾 \\
		\texttt{ios::trunc} & ~ & 打开一个文件；如有同名文件，则将原有内容全部清除 \\
		~ & ~ & {\kai（已经指定\texttt{out}而未指定\texttt{app}、\texttt{in}、\texttt{ate}等时默认）} \\
		\texttt{ios::binary} & 二进制 & 以二进制格式打开文件 \\
		~ & ~ & {\kai（不指定时默认以ASCII码格式打开）} \\
		\texttt{ios::nocreate} & 不新建 & 打开一个已有的文件；若文件不存在则打开失败 \\
		\texttt{ios::noreplace} & 不替换 & 打开一个新文件；若存在同名文件则打开失败 \\
		\bottomrule
	\end{tabular}
\end{table}

如果打开操作失败，\texttt{open()}函数的返回值为0（后来版本返回值为void，需要使用\texttt{is\_open()}来判断）；如果是用调用构造函数的方式打开文件，则流对象的值为0。这样，就可以先判断文件是否打开，从而判断异常，如：
\begin{lstlisting}[moreemph={ofstream}, emphstyle=\colors{qinglv}, 
	moreemph={[2]{outfile}}, emphstyle={[2]\it\ttfamily},]
	if(!outfile.open("f2.dat", ios::app))
	{
		cout << "open error";
		exit(1);
	}
\end{lstlisting}

\tboba{关闭}是解除该磁盘文件与文件流的关联，原来设置的工作方式也失效，这样，就不能再通过文件流对该文件进行I/O。关闭文件使用成员函数\texttt{close()}，如\texttt{\textit{outfile}.close();}。

\paragraph{ASCII文件的读写}
ASCII文件中每个字节均以ASCII代码形式存储，即一个字节存放一个字符。程序可从ASCII文件中读出或写入若干个字符。

由于文件流类是\texttt{istream}类或\texttt{ostream}类的派生类，ASCII文件关联到文件流对象后，可以直接用流插入运算符「\texttt{<<}」和流提取运算符「\texttt{>>}」写入和读出标准类型的数据到文件，也可以用文件流的\texttt{put()}、\texttt{get()}、\texttt{getline()}等成员函数进行字符的读写。

\zhu[.log日志文件]{
	在软件调试时，一个好技巧是将软件运行中的一些信息同时写到「日志文件」和屏幕上，以便程序员查看信息。写入.log日志文件使用文件输出流对象，输出到屏幕使用标准输出流对象，而两者输出内容完全一样，于是可以用文件/屏幕输出流\texttt{teestream}类对象来同时输出以简化代码。如：
	\vspace{3.8\baselineskip}

	可以改为：
	\vspace{4\baselineskip}

	编译器给出了许多宏定义和宏命令，来向程序中引入代码的信息。
	\begin{itemize}[leftmargin=1em]
		\item \texttt{\_\_FILE\_\_}：字符串常量，表示当前源文件名；
		\item \texttt{\_\_LINE\_\_}：十进制整型常量，代表当前程序所在代码行的行号；
		\item \texttt{\#line}\ \lstinline[style=notec]|<-行号->|\ \lstinline[style=notec]|<-文件名(可选)->|：将行号和文件名更改为指定的行号和文件名；
		\item \texttt{\_\_func\_\_}和\texttt{\_\_FUNCTION\_\_}：字符串常量，表示当前函数的函数名；
		\item \texttt{\_\_DATE\_\_}：字符串常量，表示日期，形式为「\texttt{Mmm dd yyyy}」；
		\item \texttt{\_\_TIME\_\_}：字符串常量，表示时间，形式为「\texttt{hh:mm:ss}」。
	\end{itemize}
}
\vspace{-17\baselineskip}
\begin{lstlisting}[style=notec]
	std::ofstream outfile("debug.log", ios::out);
	outflie << __FILE__ << ": " << __LINE__ << "\t" << "Variable x = " << x;
	std::cout << __FILE__ << ": " << __LINE__ << "\t" << "Variable x = " << x;
\end{lstlisting}
\vspace{0.8\baselineskip}
\begin{lstlisting}[style=notec]
	std::ofstream outfile("debug.log", ios::out);
	teestream tee(std::cout, outfile);
	tee << __FILE__ << ": " << __LINE__ << "\t" << "Variable x = " << x;
\end{lstlisting}
\vspace{8\baselineskip}

\paragraph{二级制文件的读写}

\textbf{二进制文件}是内存中数据存储形式不加转换地传送到磁盘保存的文件，又称为内存数据的\textbf{映像文件}或字节文件。打开二进制文件时，需用\texttt{ios::binary}指定为以二进制形式打开。二进制文件除了可以作为输入文件或输出文件外，还可是既能输入又能输出的文件，即关联到\texttt{fstream}类流对象。

用成员函数\texttt{read}和\texttt{write}读写二进制文件的基本格式为
\begin{lstlisting}[style=intro]
	istream & read(char * <-字符指针buffer->, int <-字节数len->);
	ostream & write(const char * <-字符指针buffer->, int <-字节数len->);
\end{lstlisting}
其中字符指针\texttt{buffer}指向内存中一段存储空间，即，保存文件中\texttt{\textit{len}}字节的数据到从指针所指向位置开始的内存空间，或读出从指针所指向位置开始\texttt{\textit{len}}字节的内存空间数据到文件。

\paragraph{文件指针操作}

每一个打开的文件都有一个\textbf{文件指针}，指向文件中当前应进行读写的位置。文件流对象中与文件指针有关的成员函数如表~\ref{Tab: 文件指针函数}~所示。
\begin{table}[ht!]
	\caption{与文件指针有关的文件流对象成员函数}\label{Tab: 文件指针函数}
	\centering
	\begin{tabular}{lll}
		\toprule
		\textbf{流成员函数} & \multicolumn{2}{l}{\textbf{该函数的作用}}\\
		\midrule
		\texttt{gcount()} & 计数 & 返回此前最后一次输入所读入的字节数 \\
		\texttt{tellg()} & 输入调整 & 返回输入文件指针的当前位置 \\
		\texttt{seekg(\textit{n})} & ~ & 移动输入文件指针到\textbf{绝对}位置\texttt{\textit{n}}字节处 \\
		\texttt{seekg(\textit{n}, ios::cur)} & ~ & 移动输入文件指针到\textbf{相对当前}位置\texttt{\textit{n}}字节处 \\
		\texttt{seekg(\textit{n}, ios::end)} & ~ & 移动输入文件指针到\textbf{相对文件尾}位置\texttt{\textit{n}}字节处 \\
		\texttt{tellp()} & 输出调整 & 返回输出文件指针的当前位置 \\
		\texttt{seekp(\textit{n})} & ~ & 移动输出文件指针到\textbf{绝对}位置\texttt{\textit{n}}字节处 \\
		\texttt{seekp(\textit{n}, ios::cur)} & ~ & 移动输出文件指针到\textbf{相对当前}位置\texttt{\textit{n}}字节处 \\
		\texttt{seekp(\textit{n}, ios::end)} & ~ & 移动输出文件指针到\textbf{相对文件尾}位置\texttt{\textit{n}}字节处 \\
		\bottomrule
	\end{tabular}
\end{table}

利用成员函数移动文件指针，可以随机地访问到文件中任一位置的数据。


\subsubsection{字串I/O流操作}

\tboba{字符串流}是以内存中用户定义的字符数组（字符串）为对象的I/O流，也称为\textbf{内存流}，其也有相应的缓冲区。如果向字符数组存入数据，当流缓冲区满或遇换行符时，缓冲区中的字符一起存入字符数组。如果是从字符数组读数据，先将字符数组中的数据送到流缓冲区，然后从缓冲区中提取数据赋给有关变量。
C++定义了3种用于字符串I/O操作的\tboba{字符串流类}：
\begin{itemize}[topsep=0pt]
	\item \texttt{istrstream}类：\texttt{istream}类的派生类，支持字串输入；
	\item \texttt{ostrstream}类，\texttt{ostream}类的派生类，支持字串输出；
	\item \texttt{strstream}类，\texttt{iostream}类的派生类，支持字串输入输出。
\end{itemize}
这些类都定义在头文件\texttt{<strstream>}中。

与文件打开类似，字符串流也需要自己建立字符串流对象，并与指定的字符数组关联。\texttt{ostrstream}类构造函数声明为
\begin{lstlisting}[style=intro]
	ostrstream::ostrstream(char * <-字符数组->, int <-缓冲区大小->, int <-输入输出方式-> = ios::out);
\end{lstlisting}
\texttt{strstream}类构造函数与此相同。\texttt{istrstream}类有两个带参构造函数的重载，声明分别为：
\begin{lstlisting}[style=intro]
	istrstream::istrstream(char * <-字符数组->);
	istrstream::istrstream(char * <-字符数组->, int <-读取长度->);
\end{lstlisting}
若使用后者，则只讲字符数组中前\,\lstinline[style=intro]|<-读取长度->|\,个字节的内容放入输入字符串流。

在将其他类型数据转换到字符串流中时，应特别注意如何分隔两个相邻的数据，以便于从字符串流中读出。

\zhu[字符串流的使用范围]{
	\hang[2]（1）标准流不能保存数据，文件流保存数据需要建立、打开文件，而字符数组中的内容可以随时用ASCII字符输出，比外存文件使用方便，存取速度更快；
	
	\hang[2]（2）字符数组的生命周期与其所在的模块（如主函数）相同，该模块的生命周期结束后，字符数组也不存在了，因此字符串流只适合短期保存数据。
}

\subsection{异常处理}

\tboba{异常}是指程序在运行时超出了程序员预计的某些特殊情况，不在正常的情况之列，如文件打开失败、内存分配失败、外部模块调用失败、非法指针、非法运算（除数为0）、数组访问越界、函数输入输出参数值超出预期范围、未初始化的变量使用、算法逻辑错误等。程序除了处理正常情况，还要对异常情况进行及时甄别，正确处理，以防引发更大的错误。

\kai
造成异常的原因有两种：
\begin{itemize}[topsep=0pt]
	\item 一是因为我们的程序自身存在错误，无法完成所要求的工作。程序的错误包括编译时错误和运行时错误两种，即使编译通过的程序，仍然可能存在严重的错误和漏洞，导致运行时错误。
	\item 二是因为我们的程序所调用的外部模块发生错误，致使我们的程序无法继续正常运行。每一个程序都需要依赖外部模块提供的输入输出、函数运算等系统功能，我们的程序在调用这些外部函数时，可能会遇到错误。
\end{itemize}
C++对异常采用\textbf{结构化处理}的方式，其基本思想是发现与处理分离、逐级上报：
\begin{itemize}[topsep=0pt]
	\item 发现与处理分离机制。使底层的函数专门用于解决实际任务，而不必再承担处理异常的任务，以减轻底层函数的负担而把处理异常的任务上移到某一层去处理，可提高效率。
	\item 逐级上报机制。如果在执行一个函数过程中出现异常，发出一个信息给它上一级（即调用它的函数），上级捕捉到信息后进行处理。如果上一级函数也不能处理，就再传给其上一级。如此逐级上报。如果到最高一级（操作系统级）还无法处理，最后调用\texttt{terminate()}终止程序。
\end{itemize}
\normalfont C++异常处理的~\tboba{try-catch结构}为
\begin{lstlisting}[style=intro]
	try 
	{
		// 经过一系列检查语句发现异常
		throw <-异常信息->;
	}
	catch(<-异常类型->)
	{
		// 进行异常处理
	}
\end{lstlisting}
其中，\texttt{throw}抛出的\,\lstinline[style=intro]|<-异常信息->|\,是一个表达式，\texttt{throw}抛出这个表达式后其所在函数即结束执行，先在本函数中找与之\textbf{数据类型匹配}的\texttt{catch}，如无try-catch结构或找不到匹配的\texttt{catch}，则转到最近的上级try-catch结构。如最终找不到匹配的catch块，则系统会调用函数\texttt{terminate()}来终止程序运行。

\zhu[try-catch结构的使用]{
	\hang[2]（1）try-catch结构具有整体性。catch块须紧跟try块，二者之间不能插入其他语句。但在一个try-catch结构中，可只有try块而无catch块，或一个try块后跟多个catch块。

	\hang[2]（2）\texttt{catch}语句检测的只是信息类型，因此\texttt{catch}的参数可只标明类型，如\texttt{catch(double)}。如没有指定类型，而是删节号「\texttt{…}」，则表示可捕捉任何类型异常信息。
	
	（3）如果在\texttt{catch}的参数中写入变量，如\texttt{catch(double \textit{b})}，则可实现\texttt{throw \textit{a};}中\texttt{\textit{a}}到\texttt{\textit{b}}值传递。
	
	（4）\texttt{throw}可不包括表达式，表示这一级不处理此异常，请上级处理，调用栈向上传播。
}

下面是一个例子。

\begin{lstlisting}
	#include <iostream>
	using namespace std;
	
	int main() 
	{
		void f1();
		try 
		{ f1(); }
		catch (double) 
		{ cout << "Caught double exception" << endl; }
		cout << "End 0" << endl;
		return 0;
	}
	
	void f1() 
	{
		void f2();
		try 
		{ f2(); }
		catch (char) 
		{ cout << "Caught char exception" << endl; }
		cout << "End 1" << endl;
	}
	
	void f2()
	{
		void f3();
		try 
		{ f3(); }
		catch (int) 
		{ cout << "Caught int exception" << endl; }
		cout << "End 2" << endl;
	}
	
	void f3()
	{
		double a = 0.;
		try 
		{ throw a; }
		catch (float) 
		{ cout << "Caught float exception" << endl; }
		cout << "End 3" << endl;
	}
\end{lstlisting}
在第39行抛出的\texttt{double}异常最终被第9行的catch块捕获，程序输出为
\begin{lstlisting}[style=output]
	Caught double exception
	End 0
\end{lstlisting}
如果让第40行捕获\texttt{double}异常（41行不修改），则程序输出变为
\begin{lstlisting}[style=output]
	Caught float exception
	End 3
	End 2
	End 1
	End 0
\end{lstlisting}

\zhu[抛出异常的预声明]{
	为了函数调用时的阅读性，建议声明函数时列出可能抛出的异常类型，缺省是指可能抛出任何类型的异常信息，如：
	\vspace{3.2\baselineskip}

	其中，异常信息可是标准或自定义类型数据。如果想声明一个不抛出异常的函数，则可写为：

	\vspace{2.5\baselineskip}
	异常指定必须同时出现在函数声明和函数定义的首行中。否则，编译系统将报告「类型不匹配」。
}
\vspace{-8.7\baselineskip}
\begin{lstlisting}[style=notec]
	double triangle(double, double, double) throw(double);
	double triangle(double, double, double) throw(int, float, char);
\end{lstlisting}
\vspace{0.8\baselineskip}
\begin{lstlisting}[style=notec]
	double triangle(double, double, double) throw();
\end{lstlisting}
\vspace{2\baselineskip}

除了抛出标准类型的异常之外，还可以抛出自定义类的异常，即\texttt{throw}一个自定义类对象。这样，理论上就可以满足任意的错误分类。

还可以对第三方函数的抛出异常进行封装，以适应本程序的异常规则。

\subsection{命名空间}

C++引入可由用户命名的作用域，用来解决程序中同名冲突问题。在不同的文件（编译单元）、函数、复合语句、类作用域等作用域中，可定义相同名字变量，互不干扰。
\tboba{命名空间}（namespace）就是由应用程序来命名的内存区域。通过命名空间机制，可以把一些全局实体分别放在各自空间中，从而来实现与其他全局同名实体区分。定义命名空间的基本格式为
\begin{lstlisting}[style=intro]
	namespace <-命名空间名->
	{
		// 空间中的所有全局实体，可以嵌套命名空间
	}
\end{lstlisting}
命名空间中的变量通过\,\lstinline[style=intro]|<-命名空间名->::<-变量名->|\,的格式调用。

利用\texttt{using}语句，可以声明本文件中某个变量名均指这一命名空间中的这一变量，如：
\begin{lstlisting}
	using nsp::Student;
	Student stu("Huang Yongfeng", 18);		// 等价于 nsp::Student stu("Huang Yongfeng", 18);
\end{lstlisting}
若直接使用整个空间，则可用\texttt{using namespace}语句，如：
\begin{lstlisting}
	using namespace nsp;
	Student stu("Huang Yongfeng", 18);		// 等价于 nsp::Student stu("Huang Yongfeng", 18);
\end{lstlisting}

\zhu[关于\texttt{using namespace std}]{
	\texttt{std}是标准C++库的命名空间，标准C++头文件中函数、类、对象和类模板都是在命名空间\texttt{std}中定义的。因此，在程序中用到C++标准库时，需要使用\texttt{std}作为限定。最简便的方式自然是在文件开头加入\texttt{using namespace std;}语句，这样在\texttt{std}中定义和声明的所有标识符在本文件中都可以作为全局量来使用。但是，这时应当绝对保证在程序中不出现与命名空间\texttt{std}的成员同名的标识符。
}


\subsection{模板和容器}

\subsubsection{函数模板和类模板}

\tboba{模板}是一种\textbf{使用「数据类型」作为参数}来产生一系列函数或类的机制，采用「类型参数」来完成不同的功能，可让用户得到类或函数声明的一种通用模式，使得类中的某些数据成员或者成员函数的参数、返回值取得不同类型。
模板是C++支持多态性的一种工具，体现出C++ 泛化（通用）编程思想，方便了更大规模的软件开发；减少了程序员编写代码的工作量。

函数模板的本质是建立一个通用函数，其函数的数据类型和形参类型不具体指定，用虚拟类型表示。定义一个函数模板的格式为：
\begin{lstlisting}[style=intro]
	template <typename/class <-虚拟类型名->>
	// 通用函数的定义
\end{lstlisting}
函数调用时，系统会根据实参类型来取代模板中虚拟类型，从而得到实现不同功能的\tboba{模板函数}，这称为\tboba{函数模板的实例化}，例如：
\begin{lstlisting}[moreemph={T}, emphstyle=\colors{qinglv}, 
	moreemph={[2]{P_array, count, aCount, bCount, cCount, aArray, bArray, cArray, i}}, emphstyle={[2]\it\ttfamily}]
	#include <iostream>
	using namespace std;
	
	template <class T>
	void outputArray(const T* P_array, const int count)
	{
		for (int i = 0; i < count; i++)
			cout << P_array[i] << " ";
		cout << endl;
	}
	
	int main()
	{
		const int aCount = 8, bCount = 8, cCount = 20;
		int aArray[aCount] = { 1, 2, 3, 4, 5, 6, 7, 8 };
		double bArray[bCount] = { 1.1, 2.2, 3.3, 4.4, 5.5, 6.6, 7.7, 8.8 };
		char cArray[cCount] = "Welcome to see you"; 
		cout << "a Array contains:" << endl; 
		outputArray(aArray, aCount); 
		cout << "b Array contains : "<<endl;
		outputArray(bArray, bCount);
		cout << "c Array contains:" << endl;
		outputArray(cArray, cCount);
		return 0;
	}
\end{lstlisting}
凡是多个函数体相同的函数都可合并为函数模板表示。
\zhu[函数模板的使用]{
	（1）函数模板的说明（定义）必须写在全局作用域，不能说明为类的成员函数，更不能嵌套在函数中。

	（2）由于模板类型实参的任意性，函数模板不具有隐式类型转换的作用。
	
	\hang[2]（3）模板函数也可以重载。在匹配调用函数时，首先匹配类型完全相同的重载函数，然后匹配类型适合的函数模板重载。只要有类型适合的函数模板重载，就不会进行隐式类型转换去调用类型不完全相同的重载函数。
}

类似于函数模板，如果若干个类的功能相同，仅仅是数据类型不同，则可以声明一个通用的\tboba{类模板}，其格式为：
\begin{lstlisting}[style=intro]
	template <typename/class <-虚拟类型名->>
	class <-类名->
	{
		// 通用成员的定义
	};
\end{lstlisting}
类模板的成员函数也可以在类模板之外定义，一般格式为：
\begin{lstlisting}[style=intro]
	template <typename/class <-虚拟类型名->>
	<-函数类型-> <-类模板名-><<-虚拟类型名->> :: <-函数名->(<-形参表->)
	{
		// 函数体
	}
\end{lstlisting}
类模板可使类中的某些数据成员、成员函数的参数或返回值能取任意类型。如果说类是对象的抽象，对象是类的实例，则\textbf{类模板是类的抽象，类是类模板的实例}。类模板也称为「参数化类」。

使用类模板时，在类模板名之后用尖括号指定类型名，程序编译时系统就会用指定类型来取代模板中虚拟类型，从而得到不同的\tboba{模板类}，这称为\tboba{类模板的实例化}。

类模板也可以进行派生。用类模板派生出新的类模板的格式为
\begin{lstlisting}[style=intro]
	template <typename/class <-基类模板的虚拟类型名->>
	class <-派生类模板名-> : <-派生方式-> <-基类模板名-><<-基类模板的虚拟类型名->>
	{
		// 派生类模板定义
	};
\end{lstlisting}
用模板类派生出新类的格式为
\begin{lstlisting}[style=intro]
	template <typename/class <-基类模板的虚拟类型名->>
	class <-派生类名-> : <-派生方式-> <-基类模板名-><<-指定的实际类型名->>
	{
		// 派生类定义
	};
\end{lstlisting}

\Subsubsection{STL与容器}

\tboba{标准模板库}（Standard Template Library，STL）采用模板和可重用组件，实现了通用数据结构以及处理这些数据的算法。STL是一套程序库，也是软件重用技术发展史上突破，提出了一种泛型（通用）程序设计模式。STL引入了一下这些概念：
\begin{itemize}
	\item \textbf{容器}\quad 常用数据结构的模板化，可表示Vector、List、Map等各种数据结构对象，每个容器表现为一个类模版。
	\item \textbf{算法}\quad sort、search、copy等常用操作函数的通用模板，适用于不同类型的数据，以迭代器作为函数参数，可灵活地处理不同长度数据集合。
	\item \textbf{迭代器}\quad 算法和容器间的「桥梁」，是一种泛型指针，保存它所操作的特定容器状态。迭代器指向容器中某位置，用运算符函数「\texttt{++}」或「\texttt{--}」前后移动，用「\texttt{*<-迭代器->}」表示指向数据。
	\item \textbf{函数对象}\quad 行为类似函数，可作为演化算法的某种策略（policy），传递算法操作的特定规则。
\end{itemize}
容器分为三类：
\begin{itemize}
	\item \textbf{顺序容器}\quad 可变长动态数组 vector、双端队列 deque、双向链表 list。其特点是元素在容器中的位置同元素的值无关，即容器是不排序的，便于扩展。
	\item \textbf{关联容器}\quad 集合 set、multiset、图 map、multimap。特点是元素是排序的。默认关联容器中的元素是从小到大排序；具有很好的查找性能。
	\item \textbf{容器适配器}\quad 在两类容器的基础上屏蔽一部分功能，突出
	或增加另一部分功能，实现了栈 stack、队
	列 queue、优先级队列 priority\_queue这3种适配器。
\end{itemize}


%----------------------------------------------
\end{document}